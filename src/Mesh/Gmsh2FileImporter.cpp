//****************************************************************
//* This file is part of the AsFem framework
//* A Simple Finite Element Method program (AsFem)
//* All rights reserved, Yang Bai/M3 Group@CopyRight 2020-present
//* https://github.com/M3Group/AsFem
//* Licensed under GNU GPLv3, please see LICENSE for details
//* https://www.gnu.org/licenses/gpl-3.0.en.html
//****************************************************************
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++ Author : Yang Bai
//+++ Date   : 2022.11.18
//+++ Purpose: Implement the gmsh2 file import function.
//+++          This mesh file must be the *.gmsh2, which should be
//+++          generated by netgen
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "Mesh/Gmsh2FileImporter.h"

int Gmsh2FileImporter::getMaxMeshDim(const string &filename)const{
    ifstream in;
    string str;
    int maxdim;
    in.open(filename.c_str(),ios::in);
    if(!in.is_open()){
        MessagePrinter::printErrorTxt("can\'t read the .gmsh2 file("+filename+"),please make sure file name is correct"
                                      " or you have the access permission");
        return false;
    }
    maxdim=-1;
    while(!in.eof()){
        getline(in,str);
        if(str.find("$Elements")!=string::npos){
            int nelmts;
            int elmtid,phyid,geoid,ntags,elmttype,dim,nodes;
            in>>nelmts;
            maxdim=-1;
            for(int e=0;e<nelmts;e++){
                in>>elmtid>>elmttype>>ntags>>phyid>>geoid;
                dim=MshFileUtils::getElmtDimFromElmtType(elmttype);
                nodes=MshFileUtils::getElmtNodesNumFromElmtType(elmttype);
                for(int i=0;i<nodes;i++) in>>geoid;
                if(dim>maxdim) maxdim=dim;
            }
            break;
        }
    }
    in.close();
    return maxdim;
}

bool Gmsh2FileImporter::importMeshFile(const string &filename,MeshData &meshdata){
    int mshMaxDim,mshMinDim;

    vector<int> ElmtPhyIDVec;
    vector<int> ElmtDimVec;
    vector<vector<int>> ElmtConn;
    map<int,int> PhyID2DimMap;

    ifstream in;
    in.open(filename.c_str(),ios::in);
    if(!in.is_open()){
        MessagePrinter::printErrorTxt("can\'t read the .gmsh2 file("+filename+"),please make sure file name is correct"
                                      " or you have the access permission");
        return false;
    }
    string str;
    double version;
    int format,size;

    mshMaxDim=-1;mshMinDim=100;

    mshMaxDim=getMaxMeshDim(filename);

    meshdata.m_mindim=0;
    meshdata.m_maxdim=mshMaxDim;

    meshdata.m_pointelmts=0;
    meshdata.m_lineelmts=0;
    meshdata.m_surfaceelmts=0;
    meshdata.m_bulkelmts=0;

    while(!in.eof()){
        getline(in,str);

        if(str.find("$MeshFormat")!=string::npos){
            // read the version, format, size
            in>>version>>format>>size;
            if(version<2.0 || version>2.2){
                MessagePrinter::printErrorTxt("version="+to_string(version)+" is not supported for gmsh2 file importer, "
                                               "please check your mesh file");
                return false;
            }
        }
        else if(str.find("$PhysicalNames")!=string::npos){
            MessagePrinter::printErrorTxt("The gmsh2 file exported from netgen should\'t contain $PhysicalNames, please check your input file");
            MessagePrinter::exitAsFem();
        }// end-of-physical-group-reading
        else if(str.find("$Nodes")!=string::npos){
            // read the nodes' coordinates
            // node-id, x, y, z
            meshdata.m_nodes=0;
            in>>meshdata.m_nodes;
            int nodeid;
            double x,y,z;
            meshdata.m_xmin=meshdata.m_ymin=meshdata.m_zmin= 1.0e16;
            meshdata.m_xmax=meshdata.m_ymax=meshdata.m_zmax=-1.0e16;
            meshdata.m_nodecoords0.resize(meshdata.m_nodes*3,0.0);
            meshdata.m_nodecoords.resize(meshdata.m_nodes*3,0.0);
            for(int i=0;i<meshdata.m_nodes;i++){
                in>>nodeid>>x>>y>>z;
                meshdata.m_nodecoords0[(nodeid-1)*3+1-1]=x;
                meshdata.m_nodecoords0[(nodeid-1)*3+2-1]=y;
                meshdata.m_nodecoords0[(nodeid-1)*3+3-1]=z;

                meshdata.m_nodecoords[(nodeid-1)*3+1-1]=x;
                meshdata.m_nodecoords[(nodeid-1)*3+2-1]=y;
                meshdata.m_nodecoords[(nodeid-1)*3+3-1]=z;

                if(x>meshdata.m_xmax) meshdata.m_xmax=x;
                if(x<meshdata.m_xmin) meshdata.m_xmin=x;
                if(y>meshdata.m_ymax) meshdata.m_ymax=y;
                if(y<meshdata.m_ymin) meshdata.m_ymin=y;
                if(z>meshdata.m_zmax) meshdata.m_zmax=z;
                if(z<meshdata.m_zmin) meshdata.m_zmin=z;
            }
            getline(in,str);
        }// end-of-node-coordinates-reading
        else if(str.find("$Elements")!=string::npos){
            meshdata.m_elements=0;
            in>>meshdata.m_elements;// total elements number
            vector<int> tempconn;
            int elmtid,phyid,geoid,ntags,elmttype,vtktype;
            int nodes,dim,elmtorder;
            string meshtypename;
            MeshType meshtype;

            meshdata.m_pointelmt_connectivity.clear();
            meshdata.m_lineelmt_connectivity.clear();
            meshdata.m_surfaceelmt_connectivity.clear();
            meshdata.m_bulkelmt_connectivity.clear();

            meshdata.m_pointelmts=0;
            meshdata.m_lineelmts=0;
            meshdata.m_surfaceelmts=0;
            meshdata.m_bulkelmts=0;

            meshdata.m_lineelmt_type=MeshType::EDGE2;
            meshdata.m_surfaceelmt_type=MeshType::TRI3;

            ElmtPhyIDVec.resize(meshdata.m_elements,0);
            ElmtDimVec.resize(meshdata.m_elements,0);
            ElmtConn.resize(meshdata.m_elements);
            PhyID2DimMap.clear();

            for(int e=0;e<meshdata.m_elements;e++){
                in>>elmtid>>elmttype>>ntags>>phyid>>geoid;

                nodes=MshFileUtils::getElmtNodesNumFromElmtType(elmttype);
                dim=MshFileUtils::getElmtDimFromElmtType(elmttype);
                vtktype=MshFileUtils::getElmtVTKCellTypeFromElmtType(elmttype);
                meshtype=MshFileUtils::getElmtMeshTypeFromElmtType(elmttype);
                meshtypename=MshFileUtils::getElmtMeshTypeNameFromElmtType(elmttype);
                elmtorder=MshFileUtils::getElmtOrderFromElmtType(elmttype);

                // read the connectivity info
                tempconn.resize(nodes,0);
                for(int j=0;j<nodes;j++) in>>tempconn[j];

                MshFileUtils::reorderGmsh2NodesIndex(elmttype,tempconn);

                if(dim<mshMinDim) mshMinDim=dim;

                ElmtDimVec[elmtid-1]=dim;
                ElmtPhyIDVec[elmtid-1]=phyid;
                ElmtConn[elmtid-1]=tempconn;
                PhyID2DimMap[phyid]=dim;

                if(dim==0){
                    // for node case
                    if(tempconn.size()!=1){
                        MessagePrinter::printErrorTxt("Invalid node set (element) in your gmsh2 file, the nodal connectivity array should contain only 1 node");
                        MessagePrinter::exitAsFem();
                    }
                    meshdata.m_pointelmts+=1;
                    meshdata.m_pointelmt_volume.push_back(0.0);
                    meshdata.m_pointelmt_connectivity.push_back(tempconn);
                }
                
                if(dim==1 && dim<mshMaxDim){
                    meshdata.m_lineelmts+=1;
                    meshdata.m_lineelmt_connectivity.push_back(tempconn);
                    meshdata.m_lineelmt_type=meshtype;
                    meshdata.m_lineelmt_volume.push_back(0.0);
                    meshdata.m_nodesperlineelmt=nodes;
                }
                if(dim==2 && dim<mshMaxDim){
                    meshdata.m_surfaceelmts+=1;
                    meshdata.m_surfaceelmt_connectivity.push_back(tempconn);
                    meshdata.m_surfaceelmt_type=meshtype;
                    meshdata.m_surfaceelmt_volume.push_back(0.0);
                    meshdata.m_nodespersurfaceelmt=nodes;
                }

                if(dim==mshMaxDim){
                    meshdata.m_bulkelmts+=1;
                    meshdata.m_bulkelmt_connectivity.push_back(tempconn);
                    meshdata.m_bulkelmt_type=meshtype;
                    meshdata.m_bulkelmt_typename=meshtypename;
                    meshdata.m_bulkelmt_volume.push_back(0.0);
                    meshdata.m_bulkelmt_vtktype=vtktype;
                    meshdata.m_order=elmtorder;
                    meshdata.m_nodesperbulkelmt=nodes;
                }
            }// end-of-element-loop-for-element-reading

            // before we jump out, we check the consistency between different elements
            if(meshdata.m_pointelmts
              +meshdata.m_lineelmts
              +meshdata.m_surfaceelmts
              +meshdata.m_bulkelmts!=meshdata.m_elements){
                MessagePrinter::printErrorTxt("The elements number dosen\'t match with the total one, please check your gmsh2 file");
                return false;
            }
        } // end-of-element-reading
    }// end-of-msh-file-reading
    in.close();

    meshdata.m_mindim=mshMinDim;

    // The gmsh2 file from netgen should not contain the physical group information, otherwise, please use

    // by default, the gmsh2 should not contain any physical group information, in this case, we use the elemental phyid to classify them
    vector<int> UniqueElmtPhyIDVec;
    UniqueElmtPhyIDVec=ElmtPhyIDVec;
    sort(UniqueElmtPhyIDVec.begin(),UniqueElmtPhyIDVec.end());
    UniqueElmtPhyIDVec.erase(unique(UniqueElmtPhyIDVec.begin(),UniqueElmtPhyIDVec.end()),UniqueElmtPhyIDVec.end());
    // now we prepare and create the 'new' physical group info
    meshdata.m_phygroups=static_cast<int>(UniqueElmtPhyIDVec.size())+1;

    meshdata.m_phygroup_dimvec.clear();
    meshdata.m_phygroup_phyidvec.clear();
    meshdata.m_phygroup_phynamevec.clear();

    meshdata.m_phygroup_name2dimvec.clear();
    meshdata.m_phygroup_name2phyidvec.clear();
    meshdata.m_phygroup_phyid2namevec.clear();

    meshdata.m_phygroup_elmtnumvec.clear();

    meshdata.m_phygroup_name2bulkelmtidvec.clear();
    meshdata.m_phygroup_name2elmtconnvec.clear();

    meshdata.m_phygroup_nodesnumperelmtvec.clear();

    int phyid,maxphyid,dim;
    int lowdimphygroupnums,bulkelmtphygroupnums;
    string phyname;
    maxphyid=-1;
    lowdimphygroupnums=0;
    bulkelmtphygroupnums=0;
    for(int i=0;i<meshdata.m_phygroups-1;i++){
        phyid=UniqueElmtPhyIDVec[i];
        if(phyid>maxphyid) maxphyid=phyid;
        dim=-1;
        for(const auto &it:PhyID2DimMap){
            if(it.first==phyid){
                dim=it.second;break;
            }
        }
        if(dim<0){
            MessagePrinter::printErrorTxt("can\'t find phyid(="+to_string(phyid)+" from your element, please check your gmsh2 file");
            MessagePrinter::exitAsFem();
        }
        phyname=to_string(phyid);
        meshdata.m_phygroup_dimvec.push_back(dim);
        meshdata.m_phygroup_phyidvec.push_back(phyid);
        meshdata.m_phygroup_phynamevec.push_back(phyname);

        meshdata.m_phygroup_name2dimvec.push_back(make_pair(phyname,dim));
        meshdata.m_phygroup_name2phyidvec.push_back(make_pair(phyname,phyid));
        meshdata.m_phygroup_phyid2namevec.push_back(make_pair(phyid,phyname));
        if(dim==1 && dim<mshMaxDim){
            meshdata.m_phygroup_nodesnumperelmtvec.push_back(meshdata.m_nodesperlineelmt);
            lowdimphygroupnums+=1;
        }
        
        if(dim==2 && dim<mshMaxDim){
            meshdata.m_phygroup_nodesnumperelmtvec.push_back(meshdata.m_nodespersurfaceelmt);
            lowdimphygroupnums+=1;
        }

        if(dim==mshMaxDim){
            meshdata.m_phygroup_nodesnumperelmtvec.push_back(meshdata.m_nodesperbulkelmt);
            bulkelmtphygroupnums+=1;
        }
    }
    // for all the domain
    meshdata.m_phygroup_dimvec.push_back(mshMaxDim);
    meshdata.m_phygroup_phyidvec.push_back(maxphyid+1);
    meshdata.m_phygroup_phynamevec.push_back("alldomain");

    meshdata.m_phygroup_name2dimvec.push_back(make_pair("alldomain",mshMaxDim));
    meshdata.m_phygroup_name2phyidvec.push_back(make_pair("alldomain",maxphyid+1));
    meshdata.m_phygroup_phyid2namevec.push_back(make_pair(maxphyid+1,"alldomain"));

    meshdata.m_phygroup_nodesnumperelmtvec.push_back(meshdata.m_nodesperbulkelmt);// for alldomain

    meshdata.m_phygroup_name2bulkelmtidvec.resize(bulkelmtphygroupnums+1);
    meshdata.m_phygroup_name2elmtconnvec.resize(meshdata.m_phygroups);
    meshdata.m_phygroup_elmtnumvec.resize(meshdata.m_phygroups,0);

    // now we need to loop all the elements and clasify all the element sets
    int subelmts=meshdata.m_pointelmts+meshdata.m_lineelmts+meshdata.m_surfaceelmts;
    for(int e=0;e<meshdata.m_elements;e++){
        phyid=ElmtPhyIDVec[e];
        dim=ElmtDimVec[e];
        for(int i=0;i<meshdata.m_phygroups-1;i++){
            if(phyid==meshdata.m_phygroup_phyidvec[i]){
                phyname=meshdata.m_phygroup_phynamevec[i];
                dim=meshdata.m_phygroup_dimvec[i];
                meshdata.m_phygroup_elmtnumvec[i]+=1;

                meshdata.m_phygroup_name2elmtconnvec[i].first=phyname;
                meshdata.m_phygroup_name2elmtconnvec[i].second.push_back(ElmtConn[e]);
                if(dim==mshMaxDim){
                    // for volume mesh
                    meshdata.m_phygroup_name2bulkelmtidvec[i-lowdimphygroupnums].first=phyname;
                    meshdata.m_phygroup_name2bulkelmtidvec[i-lowdimphygroupnums].second.push_back(e-subelmts+1);
                }
            }
        }// end-of-phygroup-loop
        if(dim==mshMaxDim){
            // for "alldomain"
            meshdata.m_phygroup_name2bulkelmtidvec[bulkelmtphygroupnums].first="alldomain";
            meshdata.m_phygroup_name2bulkelmtidvec[bulkelmtphygroupnums].second.push_back(e-subelmts+1);

            meshdata.m_phygroup_name2elmtconnvec[meshdata.m_phygroups-1].first="alldomain";
            meshdata.m_phygroup_name2elmtconnvec[meshdata.m_phygroups-1].second.push_back(ElmtConn[e]);
        }
    }// end-of-element-loop
    // add "alldomain" info
    phyname="alldomain";
    meshdata.m_phygroup_elmtnumvec[meshdata.m_phygroups-1]=meshdata.m_bulkelmts;
            
    meshdata.m_nodal_phygroups=0;
    meshdata.m_nodephygroup_name2nodeidvec.clear();
    meshdata.m_nodephygroup_name2phyidvec.clear();
    meshdata.m_nodephygroup_phyid2namevec.clear();
    meshdata.m_nodephygroup_phynamevec.clear();
    meshdata.m_nodephygroup_phyidvec.clear();
    

    return true;
}