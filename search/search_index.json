{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AsFem website","text":"<p>AsFem: Advanced Simulation kit based on Finite Element Method. AsFem is written in C++ and designed for phase-field modeling and multiphysics coupling. The PETSc library and MPI package are involved in AsFem for the parallel computing.</p> <p>For efficient computation and simulation, the package is written in C++ and relies heavily on the PETSc library. It is primarily developed for solid mechanics and phase-field modeling.</p> spinodal-decomposition double-notch failure"},{"location":"about/","title":"What is it?","text":"<p>Advanced Simulation kit based on Finite Element Method program for the phase-field modeling and multiphysics simulation.</p>"},{"location":"about/#what-can-it-do","title":"What can it do ?","text":"<ul> <li>[x] Solid Mechanics</li> <li>[x] CahnHilliard diffusion</li> <li>[x] Phase-field fracture model</li> <li>[x] Linear elastic materials</li> <li>[x] User-defined-Model (UM)</li> </ul>"},{"location":"about/#how-to-use-it","title":"How to use it ?","text":"<p>The documentation is under construction at present. If you have any questions, just email me: Yang</p> <p>or for Chinese users, we can also discuss more about it in the QQ group::</p> <pre><code>879908352\n</code></pre>"},{"location":"install/","title":"System requirement","text":"<ul> <li>Linux</li> <li>Windows (only works in Cygwin/Mingw, without VisualStudio. It is not recommended!!!)</li> <li>MacOX (it should work, but we haven't tested it yet!)</li> </ul>"},{"location":"install/#basic-components","title":"Basic components","text":"<p>Before we start the installation, some components are required, for example:</p> <ul> <li>gcc g++ gfortran</li> <li>cmake</li> <li>git</li> <li>python3</li> </ul> <p>In the following installation, please do not use <code>sudo</code> or <code>root</code>!!! It's only supposed to be used for system installation like <code>sudo apt install</code>, <code>sudo zypper install</code>, <code>sudo yum install</code>, and so on.</p> <p>It is highly recommended to install the openmpi and PETSc packages from the source code!</p>"},{"location":"install/#install-gcc","title":"Install gcc","text":"<p>If you don't already have a modern GCC compiler, you can use the steps listed below to install one. Otherwise, please proceed directly to the MPI setup.</p> <p>To compile a new GCC compiler, you will first need an old GCC compiler. If your system does not have one, please execute the following command (for Ubuntu) before proceeding.:</p> <pre><code>sudo apt install gcc g++ gfortran cmake git python3 build-essential\n</code></pre> <p>If you're using Ubuntu 22.04, the apt install command will provide you with the <code>GCC11.3.0</code> package, which is a suitable and up-to-date choice for our installation. As a result, you can skip the list of steps for installing GCC below. However, if you prefer, you can also install a more recent version of GCC, such as <code>GCC12.2.0</code> or even later.</p> <p>The installation process is not exclusive to Ubuntu systems. For other Linux distributions, you may need to adjust the command to match the appropriate package manager. For example, you may need to use <code>sudo zypper</code>, <code>sudo yum</code>, <code>sudo dnf</code>, and so on.:</p> <p>To get started, you will need to download and extract the source code for GCC:</p> <pre><code>curl -L -O http://mirrors.concertpass.com/gcc/releases/gcc-11.3.0/gcc-11.3.0.tar.gz\n\ntar -xf gcc-11.3.0.tar.gz\n</code></pre> <p>Alternatively, you can also directly visit the official GCC website to obtain the source code.</p> <p>Next, you will need to download the GCC prerequisites by following these steps:</p> <pre><code>cd gcc-11.3.0\n./contrib/download_prerequisites\n</code></pre> <p>we can then configure, build and install GCC:</p> <pre><code>./configure --prefix=**your-gcc-install-path** \\\n--disable-multilib \\\n--enable-languages=c,c++,fortran,jit \\\n--enable-checking=release \\\n--enable-host-shared \\\n--with-pic\n</code></pre> <p>where <code>**your-gcc-install-path**</code> represents the installation path on your own computer.</p> <p>Then one can execute:</p> <pre><code>make -j4\n</code></pre> <p>and</p> <pre><code>make install\n</code></pre> <p>During the installation process, it is necessary to configure your bash environment to use the modern GCC compiler. However, if you have installed GCC using <code>sudo apt</code>, <code>sudo yum</code>, <code>sudo zypper</code>, or any similar command, you can skip this step since your GCC is already set up and ready to use.</p> <pre><code>export gcc=your-gcc-instal-path\nexport PATH=$gcc/bin:$PATH\nexport LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/11.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/11.3.0:$LD_LIBRARY_PATH\n</code></pre> <p>You can add the aforementioned settings to your <code>~/.bashrc</code> file, or create a new file named <code>~/.asfem-profile</code> and add them there.</p>"},{"location":"install/#install-mpi","title":"Install mpi","text":"<p>If your machine already has an MPI compiler installed, you can skip this step. Otherwise, you will need to install it in order to use the PETSc package for parallelization.</p> <p>You can download the OpenMPI source code using the following command:</p> <pre><code>curl -L -O https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.5.tar.gz\n</code></pre> <p>Alternatively, you can get the source code from openmpi.</p> <p>Next, you can configure, build, and install OpenMPI. If you installed GCC by compiling the source code rather than using <code>sudo apt install</code>, please execute <code>source ~/.asfem-profile</code> to set up your environment before proceeding with the following step.</p> <pre><code>tar -xf openmpi-4.1.5.tar.gz\ncd openmpi-4.1.5\n./configure --prefix=*your-path-to-opemmpi*\nmake -j8\nmake install\n</code></pre> <p>once again, <code>*your-path-to-opemmpi*</code> should be your own installation path.</p> <p>Once you have installed OpenMPI, you will need to add the necessary settings to your bash environment as follows:</p> <pre><code>export MPI_DIR=your-path-to-openmpi\n\nexport PATH=$PATH:$MPI_DIR/bin\n\n# please comment out the following four lines until the PETSc has installed !!!\n#export CC=mpicc\n#export CXX=mpicxx\n#export FC=mpif90\n#export F90=mpif90\n\nexport OMP_NUM_THREADS=1\n\nexport C_INCLUDE_PATH=$MPI_DIR/include:$C_INCLUDE_PATH\nexport CPLUS_INCLUDE_PATH=$MPI_DIR/include:$CPLUS_INCLUDE_PATH\nexport FPATH=$MPI_DIR/include:$FPATH\nexport MANPATH=$MPI_DIR/share/man:$MANPATH\nexport LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH\n</code></pre> <p>Now one can execute the <code>source ~/.asfem-profile</code> command, and then do:</p> <pre><code>mpirun -np 4 echo \"Hi\"\n</code></pre> <p>you should see 4x\"Hi\" in your terminal.</p>"},{"location":"install/#install-petsc","title":"Install PETSc","text":"<p>Before proceeding, ensure that your GCC and MPI compilers are up to date by executing <code>source ~/.asfem-profile</code>, (If you have installed both GCC and MPI using sudo commands, then the newly opened terminal will automatically recognize the gcc and mpicc compilers, and you will not need to execute <code>source ~/.bashrc</code> or <code>source ~/.asfem-profile</code> !):</p> <pre><code>source ~/.asfem-profile\ngcc --version\nmpicxx --version\n</code></pre> <p>Plase keep in mind, these four lines should be commented in your <code>~/.asfem-profile</code> (You can also uncomment these lines, but please make sure that the <code>MPI_DIR</code> is set correctly to match the selected mpicxx compiler.)</p> <pre><code>#export CC=mpicc\n#export CXX=mpicxx\n#export FC=mpif90\n#export F90=mpif90\n</code></pre> <p>By specifying the path to OpenMPI (mpicxx,mpicc, etc.), PETSc will be able to locate the appropriate compiler.</p> <p>You can download the PETSc package using the following command (you can change the version number to any desired version, such as <code>petsc-3.18.2.tar.gz</code> or <code>petsc-3.19.1.tar.gz</code>):</p> <pre><code>curl -L -O  https://ftp.mcs.anl.gov/pub/petsc/release-snapshots/petsc-lite-3.18.6.tar.gz\n</code></pre> <p>or you can download it from the PETSc website.</p> <p>For the configuration, one can use:</p> <pre><code>./configure \\\n--prefix=***your-PETSc-install-path*** \\\n--with-debugging=0 \\\n--with-ssl=0 \\\n--with-pic=1 \\\n--with-openmp=0 \\\n--with-mpi-dir=***your-MPI-install-path*** \\\n--with-shared-libraries=1 \\\n--with-cxx-dialect=C++14 \\\n--with-fortran-bindings=1 \\\n--with-sowing=0 \\\n--download-fblaslapack=1 \\\nCOPTFLAGS='-fPIC -O3 -march=native -mtune=native ' \\\nCXXOPTFLAGS='-fPIC -O3 -march=native -mtune=native ' \\\nFOPTFLAGS='-fPIC -O3 -march=native -mtune=native ' \\\nPETSC_DIR=`pwd`\n</code></pre> <p>Once again, please note that <code>***your-PETSc-install-path***</code> should be replaced with the actual path where you want to install PETSc, and <code>***your-MPI-install-path***</code> should be replaced with the path to your MPI installation. Please ensure that the <code>--with-mpi-dir</code> option is set up correctly.</p> <p>Finally, to complete the installation, run the command shown by PETSc in your terminal using the <code>make xxxx -j8</code> and <code>make xxxx install</code> commands. Replace <code>xxx</code> with the appropriate command line shown in your terminal(Note that the commands for your particular installation may be different, so please do not copy and modify the commands shown here. Instead, copy the commands specific to your own installation from your terminal!)</p> <p>If the <code>-march=native</code> and <code>-mtune=native</code> flags do not work on your system, you should remove them from the compiler flags.</p> <p>It is important to note that if you wish to use the <code>lu</code> preconditioner or the direct solver, you will need to add one of the following lines for the lu solver:</p> <pre><code>--download-superlu_dist=1\n--download-mumps=1\n</code></pre> <p>Afterwards, add the necessary settings to your <code>~/.asfem-profile</code>. Please note that you will need to uncomment <code>export CC=xxx</code> options. Here is an example of a complete <code>~/.asfem-profile</code> file that includes the necessary settings for using PETSc.</p> <pre><code>export gcc=***your-path-to-gcc-install-path***\nexport PETSC_DIR=***your-path-to-petsc-install-dir***\nexport MPI_DIR=***your-path-to-openmpi***\n\nexport PATH=$gcc/bin:$PATH\nexport PATH=$MPI_DIR/bin:$PATH\n\nexport LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/11.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/11.3.0:$LD_LIBRARY_PATH\n\nexport CC=$MPI_DIR/bin/mpicc\nexport CXX=$MPI_DIR/bin/mpicxx\nexport FC=$MPI_DIR/bin/mpif90\nexport F90=$MPI_DIR/bin/mpif90\n\nexport C_INCLUDE_PATH=$MPI_DIR/include:$C_INCLUDE_PATH\nexport CPLUS_INCLUDE_PATH=$MPI_DIR/include:$CPLUS_INCLUDE_PATH\nexport FPATH=$MPI_DIR/include:$FPATH\nexport MANPATH=$MPI_DIR/share/man:$MANPATH\nexport LD_LIBRARY_PATH=$MPI_DIR/lib:$LD_LIBRARY_PATH\n\nexport OMP_NUM_THREADS=1\n</code></pre> <p>Once again, if you have installed GCC and OpenMPI using <code>sudo</code> commands, you only need to add the PETSc settings to your <code>~/.asfem-profile</code>. Here are some sample commands for configuring your profile:</p> <pre><code>export PETSC_DIR=***your-path-to-petsc-install-dir***\nexport MPI_DIR=***your-path-to-openmpi***\n\nexport CC=$MPI_DIR/bin/mpicc\nexport CXX=$MPI_DIR/bin/mpicxx\nexport FC=$MPI_DIR/bin/mpif90\nexport F90=$MPI_DIR/bin/mpif90\n\nexport OMP_NUM_THREADS=1\n</code></pre>"},{"location":"install/#install-asfem","title":"Install AsFem","text":"<p>Download AsFem:</p> <pre><code>git clone https://github.com/M3Group/AsFem.git\n</code></pre> <p>if you wish to try the devel version (which is considered to be unstable), you can use the following command:</p> <pre><code>git clone -b devel https://github.com/M3Group/AsFem.git\n</code></pre> <p>After executing source ~/.asfem-profile, you can obtain the <code>Makefile</code> using the following command:</p> <pre><code>cmake CMakeLists.txt -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>After obtaining the <code>Makefile</code>, you can build <code>asfem</code> by executing the following command:</p> <pre><code>make -j4\n</code></pre> <p>Once you have built <code>asfem</code>, you can find the executable file in the <code>AsFem/bin</code> folder.</p> <p>It is highly recommended to add the <code>AsFem/bin</code> directory to your <code>PATH</code> environment variable as follows:</p> <pre><code>export asfem=**your-path-to-asfem**\nexport PATH=$PATH:$asfem/bin\n</code></pre> <p>After adding the <code>AsFem/bin</code> directory to your PATH environment variable, you can easily run an AsFem job from the terminal using the following command:</p> <pre><code>asfem -i yourjob.json\nmpirun -np 16 asfem -i yourjob.json\n</code></pre> <p>That's all, enjoy!</p>"},{"location":"release/","title":"Release","text":"<p>All the release can be download from here AsFem-Release</p>"},{"location":"release/#version-v05-is-released","title":"\ud83c\udf1f Version <code>v0.5</code> is released!","text":""},{"location":"release/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>Name-based material properties accessing</li> <li>Further simplify the user element coding, nodal loop is required anymore</li> <li>Citation is available in Zenodo</li> </ul>"},{"location":"release/#features","title":"\u2b50 Features","text":"<ul> <li>Material properties projection</li> <li>Postprocesses for elemental and side DoFs/Materials integral</li> </ul>"},{"location":"release/#bug-fixes","title":"\ud83d\udc1e Bug Fixes","text":"<ul> <li>Fix setting errors in Gmsh2IO and Gmsh4IO</li> </ul>"},{"location":"release/#improvements","title":"\ud83d\udee0 Improvements","text":"<ul> <li>Error detector for the boundary condition system</li> </ul>"},{"location":"Document/block-bcs/","title":"[bcs] block","text":"<p>The block <code>[bcs]</code> is used to apply the different types of boundary conditions, i.e. Dirichlet boundary condition, Neumann boundary condition, Robin boundary condition, as well as User-Defined-BC (UBC). This block's layout looks as follows:</p> <pre><code>[bcs]\n  [mybc1]\n    type=dirichlet\n    dofs=dof1\n    boundary=left right ...\n    value=bcvalue\n  [end]\n[end]\n</code></pre>","tags":["blocks","input file","bcs"]},{"location":"Document/block-bcs/#options","title":"options","text":"<p>The <code>type =</code> option specifies the name of the boundary condition type one wants to use.</p> <p><code>dofs=</code> specifies which DoF we want to use. It should be noted that, more than one DoF can be accepted, for instance, <code>dofs=ux uy</code>.</p> <p><code>boundary=</code> specifies the name of the boundary, which we want to apply the related boundary condition. The name of the boundary should be defined in your mesh file. For the built-in mesh, we use <code>left</code> and <code>right</code> for the point/line/surface at <code>xmin</code> and <code>xmax</code>. Similarly, <code>bottom</code> and <code>top</code> are used for the line/surface at <code>ymin</code> and <code>ymax</code>. Then <code>back</code> and <code>front</code> are used for the surface at <code>zmin</code> and <code>zmax</code>.</p> <p><code>value=</code> specifies the boundary value we want to use. It should be a single value, instead of several numbers. If one wants to apply the time dependent boundary condition, then he can use <code>value=t*2.0</code>. Thus the boundary value will change overtime.</p>","tags":["blocks","input file","bcs"]},{"location":"Document/block-bcs/#supported-boundary-condition-type","title":"supported boundary condition type","text":"<p>The full list of the available boundary condition type is:</p> <pre><code>type=dirichlet\ntype=nodaldirichlet\ntype=neumann\ntype=nodalneumann\ntype=user1bc[,user2bc,user3bc,...]\ntype=user1dirichletbc[,user2dirichletbc,...]\n</code></pre>","tags":["blocks","input file","bcs"]},{"location":"Document/block-dofs/","title":"[dofs] block","text":"<p>The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions (<code>[bcs]</code>), elements (<code>[elmts]</code>), and so on. The <code>[dofs]</code> block looks like below:</p> <pre><code>[dofs]\nname=dof1 dof2 dof3 ...\n[end]\n</code></pre>","tags":["blocks","input file","dofs"]},{"location":"Document/block-dofs/#dofs-block-option","title":"[dofs] block option","text":"<p>The <code>name=</code>  option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely <code>disp_x</code> and <code>disp_y</code>, if we want to do a 2D elastic analysis. The block of <code>[dofs]</code> should therefore be specified as:</p> <pre><code>[dofs]\nname=disp_x disp_y\n[end]\n</code></pre> <p>where <code>disp_x</code> is the first DoF(index=1), <code>disp_y</code> is the second DoF(index=2).</p> <p>That's all, <code>name=</code> is the only option in <code>[dofs]</code> block, nothing else.</p>","tags":["blocks","input file","dofs"]},{"location":"Document/block-elmts/","title":"[elmts] block","text":"<p>The block <code>[elmts]</code> is used to describe the model that we plan to use according to your particular problem. This block's layout looks as follows:</p> <pre><code>[elmts]\n  [subelmts1]\n    type=elment-type2\n    dofs=dof1 dof2\n    mate=mate-name1\n    domain=geometry-domain-name1\n  [end]\n  [subelmts2]\n    type=elment-type2\n    dofs=dof1 dof2\n    mate=mate-name2\n    domain=geometry-domain-name2\n  [end]\n  ...\n[end]\n</code></pre>","tags":["blocks","input file","elmts"]},{"location":"Document/block-elmts/#options","title":"options","text":"<p>The <code>type =</code> option specifies the name of the element type (or the physical model) one wants to use.</p> <p><code>dofs=</code> specifies which DoFs we want to use, it should be noted that one of the names in your <code>[dofs]</code> block must be the name we used here.</p> <p><code>mate=</code> gives the material name, which should be the block name in your material block, not the material type name!!! This option can be ignored, then your element will not call any material calculation.</p> <p><code>domain=</code> determines which domain will be applied to the current element. Users don't usually need this option, then all of your mesh domains will be used by default.</p>","tags":["blocks","input file","elmts"]},{"location":"Document/block-elmts/#supported-element-type","title":"supported element type","text":"<p>The full list of the available element type is:</p> <pre><code>type=poisson\ntype=mechanics\ntype=diffusion\ntype=cahnhilliard\ntype=user1[,...,user20]\n</code></pre>","tags":["blocks","input file","elmts"]},{"location":"Document/block-ics/","title":"[ics] block","text":"<p>The block <code>[ics]</code> is used to apply the initial condition for the DoFs. This block's layout looks as follows:</p> <pre><code>[ics]\n  [ic1]\n    type=const\n    dof=dof1\n    domain=domain-name\n    params=val1 val2 ...\n  [end]\n  ...\n[end]\n</code></pre>","tags":["blocks","input file","ics"]},{"location":"Document/block-ics/#options","title":"options","text":"<p>The <code>type =</code> option specifies the name of the initial condition type one wants to use.</p> <p><code>dof=</code> specifies the name of the DoF.</p> <p><code>domain=</code> indicates the domain name where the initial condition will be applied.</p> <p><code>params=</code> gives the parameters which will be used in the initial condition calculation.</p>","tags":["blocks","input file","ics"]},{"location":"Document/block-ics/#supported-initial-condition-type","title":"supported initial condition type","text":"<p>The full list of the available initial condition typ is:</p> <pre><code>type=const\ntype=random\ntype=circle\ntype=sphere\ntype=rectangle\ntype=cubic\n</code></pre>","tags":["blocks","input file","ics"]},{"location":"Document/block-mates/","title":"[mates] block","text":"<p>The block <code>[mates]</code> is used to calculate the material properties we plan to use according to our model, therefore, the material properties will be used by the <code>[elmts]</code> block. This block's layout looks as follows:</p> <pre><code>[mates]\n  [mymate1]\n    type=linearelastic\n    params=210.0 0.3\n  [end]\n  [mymate2]\n    type=linearelastic\n    params=410.0 0.2\n  [end]\n  ...\n[end]\n</code></pre> <p>It should be noted that, the name of the block <code>mymate1</code> should be the same as the one you give in <code>[elmts]</code> subblock(the <code>mate=mymate1</code> option).</p>","tags":["blocks","input file","mates"]},{"location":"Document/block-mates/#options","title":"options","text":"<p>The <code>type =</code> option specifies the name of the element type (or the physical model) one wants to use.</p> <p><code>params=</code> specifies the parameters we want to use in the material property calculation.</p>","tags":["blocks","input file","mates"]},{"location":"Document/block-mates/#supported-material-type","title":"supported material type","text":"<p>The full list of the available element type is:</p> <pre><code>type=constpoisson\ntype=linearelastic\ntype=cahnhilliard\ntype=user1[,...,user10]\n</code></pre>","tags":["blocks","input file","mates"]},{"location":"Document/block-mesh/","title":"[mesh] block","text":"<p>The format of the block is:</p> <pre><code>[mesh]\n  type=asfem\n  dim=1\n  xmin=0.0\n  xmax=1.0\n  nx=10\n  meshtype=edge2\n  savemesh=true\n[end]\n</code></pre>","tags":["blocks","input file","mesh"]},{"location":"Document/block-mesh/#mesh-block-options","title":"[mesh] block options","text":"<p><code>type=</code>  option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( <code>type=gmsh</code> ) or netgen ( <code>type=gmsh2</code> ).</p> <p><code>dim=</code>  determines the domain's dimension, which should be 1, 2, or 3.</p> <p><code>xmin=</code> and <code>xmax=</code> denote the size of the domain, you will need <code>ymin=</code> and <code>ymax=</code> for the 2D case, and <code>zmin=</code> and <code>zmax=</code> in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely <code>[1]</code> in 1D, <code>[1,1]</code> in 2D, <code>[1,1,1]</code> in 3D.</p> <p>Simultaneously, <code>nx</code>, <code>ny</code>, and <code>nz</code> represent the number of mesh along these three axes, respectively.</p> <p><code>meshtype=</code> option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via <code>meshtype=edge3</code>. Currently, AsFem offers:</p> <pre><code>edge2,edge3,edge4 // in 1D case\nquad4,quad8,quad9 // in 2D case\nhex8, hex20,hex27 // in 3D case\n</code></pre> <p>If one want to save the created mesh, one will need the <code>savemesh=true</code> option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' (.i is removed from your input file name). For example, if your input file is: test.i, then the mesh file name is: test_mesh.vtu.</p>","tags":["blocks","input file","mesh"]},{"location":"Document/block-nonlinearsolver/","title":"[nonlinearsolver] block","text":"<p>The block <code>[nonlinearsolver]</code> is used for the newton-raphson nonlinear iteration. This block's layout looks as follows:</p> <pre><code>[nonlinearsolver]\n  type=nr\n  maxiters=25\n  r_rel_tol=1.0e-8\n  r_abs_tol=1.0e-7\n  stol=1.0e-16\n  solver=superlu\n[end]\n</code></pre>","tags":["blocks","input file","nonlinear solver"]},{"location":"Document/block-nonlinearsolver/#options","title":"options","text":"<p>The <code>type =</code> option specifies the name of the nonlinear solver method one wants to use.</p> <p><code>maxiters=</code> specifies maximum nonlinear iterations.</p> <p><code>r_rel_tol</code> and <code>r_abs_tol</code> represent the relative and absolute errors of the residual(\\(||R||\\)).</p> <p><code>stol=</code> determines tolerance of the displacement error, namely \\(||\\Delta U||\\).</p> <p><code>solver=</code> indicates the name of linear solver, it could be: <code>ksp</code>, <code>mumps</code>, and <code>superlu</code>.</p>","tags":["blocks","input file","nonlinear solver"]},{"location":"Document/block-nonlinearsolver/#supported-nonlinear-solver-method","title":"supported nonlinear solver method","text":"<p>The full list of the available nonlinear solver method is:</p> <pre><code>type=nr // for newton-raphson with line search, the default one\ntype=newtonls // same as the first one\ntype=newtontr // NR with trust region method\ntype=bfgs     // BFGS method\ntype=broyden  // Broyden method\n</code></pre>","tags":["blocks","input file","nonlinear solver"]},{"location":"Document/block-projection/","title":"[projection] block","text":"<p>The block <code>[projection]</code> is used for projecting the quantities of the gauss point to the nodal point. This block's layout looks as follows:</p> <pre><code>[projection]\n  name=x1 x2 x3\n  scalarmate=mate1 mate2 ...\n  vectormate=vmat1 vmat2 ...\n  rank2mate=stress strain ...\n  rank4mate=jacobian ...\n[end]\n</code></pre>","tags":["blocks","input file","projection"]},{"location":"Document/block-projection/#options","title":"options","text":"<p>The <code>name=</code> option specifies the name of the scalar value you want to project, it should be calculated/defined in your element, it is independent with the material system.</p> <p><code>scalarmate=</code> specifies the name of scalar type materials you want to project, which should be defined/calculated in your materials. For example, <code>Mate.ScalarMaterials(\"myscalar\")=0.0</code>, where \"myscalar\" is the name for the vector type material.</p> <p><code>vectormate=</code> specifies the name of vector type materials you want to project, which should be defined/calculated in your materials. For example, <code>Mate.VectorMaterials(\"myvector\")=1.0</code>, where \"myvector\" is the name for the vector type material.</p> <p><code>rank2mate=</code> specifies the name of rank-2 tensor type materials you want to project, which should be defined/calculated in your materials. For example, <code>Mate.Rank2Materials(\"mystress\")=1.0</code>, where \"mystress\" is the name for the rank-2 tensor type material.</p> <p><code>rank4mate=</code> specifies the name of rank-4 tensor type materials you want to project, which should be defined/calculated in your materials. For example, <code>Mate.Rank4Materials(\"myjacobian\")=1.0</code>, where \"myjacobian\" is the name for the rank-4 tensor type material.</p> <p>Once you put the correct name of the material properties there, AsFem will automatically save them into the result file. Then you can check them easily in the Paraview.</p>","tags":["blocks","input file","projection"]},{"location":"Document/block-qpoint/","title":"[qpoint] block","text":"<p>The block <code>[qpoint]</code> is used for the gauss point integration. This block's layout looks as follows:</p> <pre><code>[qpoint]\n  type=gauss\n  order=3\n[end]\n</code></pre>","tags":["blocks","input file","qpoint"]},{"location":"Document/block-qpoint/#options","title":"options","text":"<p>The <code>type =</code> option specifies the type name of the gauss point integration.</p> <p><code>order=</code> specifies gauss integration order(it's not the number of gauss points, instead, it's the order!)</p>","tags":["blocks","input file","qpoint"]},{"location":"Document/block-qpoint/#supported-gauss-integration-method","title":"supported gauss integration method","text":"<p>The full list of the available gauss integration is:</p> <pre><code>type=gauss\ntype=gausslobatto\n</code></pre>","tags":["blocks","input file","qpoint"]},{"location":"Document/block-timestepping/","title":"[timestepping] block","text":"<p>The block <code>[timestepping]</code> is used for the transient analysis. This block's layout looks as follows:</p> <pre><code>[timestepping]\n  type=be\n  dt=1.0e-5\n  time=1.0e3\n  adaptive=true\n  optiters=3\n  growthfactor=1.1\n  cutfactor=0.85\n  dtmin=1.0e-12\n  dtmax=1.0e1\n[end]\n</code></pre>","tags":["blocks","input file","timestepping"]},{"location":"Document/block-timestepping/#options","title":"options","text":"<p>The <code>type =</code> option specifies the name of the time integration method one wants to use.</p> <p><code>dt=</code> specifies initial \\(\\Delta_{t}\\). <code>time=</code> defines the final time.</p> <p><code>adaptive=true</code> enables the adaptive time stepping. It's disabled by default.</p> <p><code>optiters=</code> determines the critical nonlinear iterations for increasing or decreasing the \\(\\Delta_{t}\\).</p> <p><code>growthfactor=</code> and <code>cutfactor=</code> represent the growth factor and cut back factor for adaptive time stepping, respectively.</p> <p><code>dtmin</code> and <code>dtmax</code> determine the minimum and maximum value of \\(\\Delta_{t}\\).</p>","tags":["blocks","input file","timestepping"]},{"location":"Document/block-timestepping/#supported-time-stepping-method","title":"supported time stepping method","text":"<p>The full list of the available time stepping method is:</p> <pre><code>type=be\ntype=cn\ntype=bdf2\n</code></pre>","tags":["blocks","input file","timestepping"]},{"location":"Examples/PhaseFieldFracture/","title":"Introduction","text":"<p>In this example, we will try to solve the phase-field fracture model which is implemented based on Prof. Miehe's Model.</p>","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Examples/PhaseFieldFracture/#model","title":"Model","text":"<p>In this model, the damage phase is described by an order parameter \\(d\\) which varies smoothly from 0 (undamaged case) to 1 (fully damaged case). Therefore, the system free energy can be read as follows: $$ \\begin{equation} \\psi=\\psi_{d}+\\psi_{e} \\label{eq:psi} \\tag{1} \\end{equation} $$ where \\(g(d)\\) is the degradation function, and the damage phase free energy \\(\\psi_{d}\\) is given as follows: $$ \\begin{equation} \\psi_{d}=\\mathcal{G}_{c}(\\frac{d^{2}}{2l}+\\frac{l}{2}\\lvert\\nabla d\\rvert^{2}) \\label{eq:psi-d} \\tag{2} \\end{equation} $$ with \\(\\mathcal{G}_{c}\\) and \\(l\\) being the critical energy release rate and the length scale parameter, respectively.</p> <p>The elastic free energy can be defined as follows: $$ \\begin{equation} \\psi_{e}=g(d)\\psi_{e}^{+}+\\psi_{e}^{-} \\label{eq:psi-e} \\tag{3} \\end{equation} $$ where $$ \\begin{equation} \\psi_{e}^{+}=\\frac{\\lambda}{2}\\langle\\mathrm{tr}(\\mathbf{\\varepsilon})\\rangle_{+}^{2}+\\mu \\mathrm{tr}[\\mathbf{\\varepsilon}_{+}^{2}] \\label{eq:psi-e-positive} \\tag{4} \\end{equation} $$</p> <p>and $$ \\begin{equation} \\psi_{e}^{-}=\\frac{\\lambda}{2}\\langle\\mathrm{tr}(\\mathbf{\\varepsilon})\\rangle_{-}^{2}+\\mu \\mathrm{tr}[\\mathbf{\\varepsilon}_{-}^{2}] \\label{eq:psi-e-negative} \\tag{5} \\end{equation} $$</p> <p>Here, \\(\\lambda\\) and \\(\\mu\\) are the lame constant and shear moduli, respectively. The positive and negative bracket operators are given as follows: $$ \\begin{equation} \\langle x\\rangle_{+}=\\frac{x+|x|}{2}\\ ,\\quad \\langle x\\rangle_{-}=\\frac{x-|x|}{2} \\label{eq:bracket} \\tag{6} \\end{equation} $$</p> <p>Thus the stress can be defined as follows: $$ \\begin{equation} \\mathbf{\\sigma}=\\frac{\\partial\\psi}{\\partial\\mathbf{\\varepsilon}} =g(d)[\\lambda\\langle\\mathrm{tr}[\\mathbf{\\varepsilon}]\\rangle_{+}\\mathbf{I}+2\\mu\\mathbf{\\varepsilon}_{+}]+[\\lambda\\langle\\mathrm{tr}[\\mathbf{\\varepsilon}]\\rangle_{-}\\mathbf{I}+2\\mu\\mathbf{\\varepsilon}_{-}] \\label{eq:stress} \\tag{7} \\end{equation} $$</p> <p>The governing equaitons for this model are list below: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-equilibrium} \\tag{8} \\end{equation} $$ and $$ \\begin{equation} \\eta\\frac{\\partial d}{\\partial t}=2(1-d)\\mathcal{H}-\\frac{\\mathcal{G}_{c}}{l}(d-l^{2}\\Delta d) \\label{eq:damage-equation} \\tag{9} \\end{equation} $$ where \\(\\eta\\) is the viscosity coefficient. The history variable \\(\\mathcal{H}\\) is calculated as follows:</p> \\[ \\begin{equation} \\mathcal{H}= \\begin{cases} \\psi_{e}^{+} &amp; \\mathrm{if}\\quad\\psi_{e}^{+}&gt;\\mathcal{H}_{n}\\\\ \\mathcal{H}_{n} &amp;\\mathrm{otherwise} \\end{cases} \\label{eq:hist} \\tag{10} \\end{equation} \\]","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Examples/PhaseFieldFracture/#input-file","title":"Input file","text":"<p>In the example/pffracture folder, there are several <code>geo</code> file, which can be used to generate the <code>msh</code> mesh file for your simulation. Before we start, you should have the mesh file.</p>","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Examples/PhaseFieldFracture/#mesh","title":"Mesh","text":"<p>In this case, we'll import the mesh from <code>gmsh</code>, which can be done as follows:</p> <pre><code>[mesh]\n  type=gmsh\n  file=sample.msh\n[end]\n</code></pre> <p>Here, you should use gmsh to generate the related msh file!</p>","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Examples/PhaseFieldFracture/#dofs","title":"Dofs","text":"<p>Next, you need to define the dofs, it should be \\(d\\), \\(u_{x}\\), and \\(u_{y}\\) for 2d case, and \\(d\\), \\(u_{x}\\), \\(u_{y}\\), and \\(u_{z}\\) for 3d case. The <code>[dofs]</code> block should looks like:</p> <pre><code>[dofs]\nname=d ux uy\n[end]\n</code></pre> <p>or</p> <pre><code>[dofs]\nname=d ux uy uz\n[end]\n</code></pre> <p>Here, the sequence of your <code>dofs</code> name matters !!!</p>","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Examples/PhaseFieldFracture/#elmts-and-mates","title":"[elmts] and [mates]","text":"<p>The governings in Eq.\\(\\eqref{eq:stress-equilibrium}\\) and Eq.\\(\\eqref{eq:damage-equation}\\) can be implemented by using the following <code>elmts</code>:</p> <pre><code>[elmts]\n  [myfracture]\n    type=miehefrac\n    dofs=d ux uy\n    mate=myfracmate\n  [end]\n[end]\n</code></pre> <p>where <code>type=miehefrac</code> tells AsFem, our users want to call the phase-field fracture model.</p> <p>For the material calculation, as mentioned before, several parameters are required, i.e., \\(E\\), \\(\\nu\\) for the Youngs modulus and poisson ration, \\(\\eta\\), \\(\\mathcal{G}_{c}\\), and \\(l\\) for the damage evolution. Therefore, the related <code>material</code> block can be given as follows:</p> <pre><code>[mates]\n  [myfracmate]\n    type=miehefracmate\n    params=121.15 80.77 2.7e-3 0.012  1.0e-6   \n    //     lambda mu    Gc     L      viscosity\n  [end]\n[end]\n</code></pre> <p>It should be mentioned that, the de-coupled or staggered solution can be done easily by introducing the <code>usehist</code> parameter as follows:</p> <pre><code>[mates]\n  [myfracmate]\n    type=miehefracmate\n    params=121.15 80.77 2.7e-3 0.012  1.0e-6     1\n    //     lambda mu    Gc     L      viscosity  usehist\n  [end]\n[end]\n</code></pre> <p>then, your \\(\\mathcal{H}\\) will always use the \\(\\mathcal{H}_{old}\\) value from previous step.</p>","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Examples/PhaseFieldFracture/#boundary-condition","title":"boundary condition","text":"<p>For the tensile test, one can use the following <code>bcs</code>:</p> <pre><code>[bcs]\n  [fixux]\n    type=dirichlet\n    dofs=ux\n    value=0.0\n    boundary=left right top bottom\n  [end]\n  [fixuy]\n    type=dirichlet\n    dofs=uy\n    value=0.0\n    boundary=bottom\n  [end]\n  [load]\n    type=dirichlet\n    dofs=uy\n    value=1.0*t\n    boundary=top\n  [end]\n[end]\n</code></pre> <p>and for the shear failure test, one can use:</p> <pre><code>[bcs]\n  [fixux]\n    type=dirichlet\n    dofs=ux\n    value=0.0\n    boundary=bottom\n  [end]\n  [fixuy]\n    type=dirichlet\n    dofs=uy\n    value=0.0\n    boundary=bottom left right top\n  [end]\n  [load]\n    type=dirichlet\n    dofs=ux\n    value=1.0*t\n    boundary=top\n  [end]\n[end]\n</code></pre> <p>Done? Yulp, all the things is done!</p>","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Examples/PhaseFieldFracture/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>Now, let's try your first phase-field fracture model in AsFem. You can create a new text file and name it as tensile.i or whatever you like. Then copy the following lines into your input file:</p> <pre><code>[mesh]\n  type=gmsh\n  file=sample.msh\n[end]\n\n\n[dofs]\nname=d ux uy\n[end]\n\n[elmts]\n  [myfracture]\n    type=miehefrac\n    dofs=d ux uy\n    mate=myfracmate\n  [end]\n[end]\n\n[mates]\n  [myfracmate]\n    type=miehefracmate\n    params=121.15 80.77 2.7e-3 0.012 1.0e-6\n    //     lambda mu    Gc     L     viscosity\n  [end]\n[end]\n\n[nonlinearsolver]\n  type=nr\n  maxiters=15\n  r_rel_tol=1.0e-10\n  r_abs_tol=5.5e-7\n[end]\n\n[ics]\n  [constd]\n    type=const\n    dof=d\n    params=0.0\n  [end]\n[end]\n\n[output]\n  type=vtu\n  interval=20\n[end]\n\n[timestepping]\n  type=be\n  dt=1.0e-5\n  time=5.0e-5\n  adaptive=false\n  optiters=3\n  growthfactor=1.1\n  cutfactor=0.85\n  dtmin=1.0e-12\n  dtmax=1.0e-4\n[end]\n\n[projection]\nscalarmate=vonMises\n[end]\n\n[bcs]\n  [fixux]\n    type=dirichlet\n    dofs=ux\n    value=0.0\n    boundary=left right top bottom\n  [end]\n  [fixuy]\n    type=dirichlet\n    dofs=uy\n    value=0.0\n    boundary=bottom\n  [end]\n  [load]\n    type=dirichlet\n    dofs=uy\n    value=1.0*t\n    boundary=top\n  [end]\n[end]\n\n[job]\n  type=transient\n  debug=dep\n[end]\n</code></pre> <p>You can also find the complete input file in <code>examples/pffracture/miehe-tensile.i</code>.</p> <p>If everything goes well, you can see the following image in your Paraview: </p> <p></p>","tags":["examples","input file","mesh","dofs","elmts","mates","stress","umat","phase field","fracture"]},{"location":"Tutorial/step-0/","title":"Step-0","text":""},{"location":"Tutorial/step-0/#write-a-simple-input-file","title":"Write a simple input file:","text":"<p>In your input file (<code>*.json</code> file), the layout of the block should resemble the following:</p> <pre><code>\"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":1,\n        \"nx\":20,\n        \"xmax\":1.5,\n        \"meshtype\":\"edge2\",\n        \"savemesh\":true\n    }\n</code></pre> <p>In this context, <code>\"mesh\"</code> represents the function or module we want to use in AsFem, and it defines a single block in the JSON file. Within this block, you can include multiple options for different purposes.</p> <p>In the aforementioned example, <code>\"mesh\"</code> defines a block for mesh generation, and within the <code>{}</code> bracket pair, you can specify the mesh type (<code>\"type\":\"asfem\"</code>), the dimension of the mesh (<code>\"dim\":1</code>), and other relevant details.</p> <p>To create a minimal input file for AsFem, you will need to include at least the following blocks:</p> <pre><code>\"mesh\": to define the finite element mesh\n\"dofs\": to define the degree of freedom\n\"elements\": to define the PDE/ODE\n\"job\": to define the static/transient analysis job\n</code></pre> <p>Within the <code>\"dofs\"</code> block, you can specify the name or list of names of the Degrees of Freedom (DoFs) that will be displayed in Paraview when you open the result file (<code>vtu</code> file). Furthermore, when applying boundary conditions, you will need to provide the name of the relevant DoFs.</p> <pre><code>\"dofs\":{\n        \"names\":[\"phi\"]\n    }\n</code></pre> <p>and the element or module you'd like to use:</p> <p>Additionally, you will need to specify the element or module you would like to use in the <code>\"elements\"</code> block. This block defines the residual and jacobian for your PDE/ODE.</p> <pre><code>\"elements\":{\n        \"elmt1\":{\n            \"type\":\"laplace\",\n            \"dofs\":[\"phi\"],\n            \"material\":{\n                \"type\":\"constpoisson\",\n                \"parameters\":{\n                    \"sigma\":1.0,\n                    \"f\":1.0e1\n                }\n            }\n        }\n    }\n</code></pre> <p>In the end, you will also need to provide the necessary information for the analysis within the <code>\"job\"</code> block.</p> <pre><code>\"job\":{\n        \"type\":\"static\",\n        \"print\":\"dep\",\n        \"restart\":true\n    }\n</code></pre> <p>To summarize, in order to create a basic input file for AsFem, you will need to include the following blocks:</p> <pre><code>{\n    \"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":2,\n        \"nx\":50,\n        \"ny\":50,\n        \"meshtype\":\"quad4\",\n        \"savemesh\":true\n    },\n    \"dofs\":{\n        \"names\":[\"phi\"]\n    },\n    \"elements\":{\n        \"elmt1\":{\n            \"type\":\"laplace\",\n            \"dofs\":[\"phi\"],\n            \"material\":{\n                \"type\":\"constpoisson\",\n                \"parameters\":{\n                    \"sigma\":1.0,\n                    \"f\":1.0e1\n                }\n            }\n        }\n    },\n    \"job\":{\n        \"type\":\"static\",\n        \"print\":\"dep\"\n    }\n}\n</code></pre> <p>In addition to performing a full FEM analysis workflow, you can use the <code>--read-only</code> option with AsFem to parse and validate the input file without executing the simulation. This option allows you to check the syntax and structure of the input file without actually running a full analysis.</p> <p>You can find examples of all the possible blocks that can be included in an AsFem input file in the <code>test_input/input-template.json</code> file.</p> <p>In the following steps, we will provide detailed explanations of each block and their functions in AsFem. You can find example input files in the <code>examples/tutorial</code> folder to help you understand the usage of each block.</p>"},{"location":"Tutorial/step-1/","title":"Introduction","text":"<p>Before performing a FEM simulation, you must define the computation domain and discretize it into multiple finite element mesh. To accomplish this, AsFem provides the <code>mesh</code> block.</p>","tags":["tutorial","input file","mesh"]},{"location":"Tutorial/step-1/#1d-example","title":"1D example","text":"<p>As an example, let's consider a 1D solid line that needs to be discretized into several 1D Lagrange meshes. This can be achieved using the following input file:</p> <pre><code>\"mesh\":{\n    \"type\":\"asfem\",\n    \"dim\":1,\n    \"nx\":20,\n    \"xmax\":1.5,\n    \"meshtype\":\"edge2\",\n    \"savemesh\":true\n}\n</code></pre>","tags":["tutorial","input file","mesh"]},{"location":"Tutorial/step-1/#options","title":"Options","text":"<p>The <code>type</code> option in the <code>mesh</code> block determines the type of mesh generation to be used. AsFem provides two types of mesh generation: built-in mesh generation for regular domains (such as 1D lines, 2D rectangles, and 3D cubes), and external mesh generation using pre-generated mesh files in standard formats such as Gmsh, Netgen, or Abaqus. For the second option, users can import their own mesh from other packages, such as Gmsh (using <code>\"type\": \"gmsh\"</code>) or Netgen (using <code>\"type\":\"gmsh2\"</code>).</p> <p>The <code>dim</code> option specifies the dimension of the computational domain, which can be either 1, 2, or 3.</p> <p><code>xmin=</code> and <code>xmax=</code> denote the size of the domain, you will need <code>ymin=</code> and <code>ymax=</code> for the 2D case, and <code>zmin=</code> and <code>zmax=</code> in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely <code>[1]</code> in 1D, <code>[1,1]</code> in 2D, <code>[1,1,1]</code> in 3D.</p> <p>The <code>xmin</code> and <code>xmax</code> options in the \"mesh\" block specify the size of the computational domain in the x-direction. For 2D cases, <code>ymin</code> and <code>ymax</code> are also needed, while for 3D cases, <code>zmin</code> and <code>zmax</code> are required. Users can also omit these options, in which case the domain size defaults to one unit, represented as <code>[1]</code> for 1D cases, <code>[1, 1]</code> for 2D cases, and <code>[1, 1, 1]</code> for 3D cases.</p> <p>The <code>nx</code>, <code>ny</code>, and <code>nz</code> options represent the number of meshes along the x, y, and z axes, respectively.</p> <p>The <code>meshtype</code> option within the <code>mesh</code> block provides different choices of mesh types. For example, second-order Lagrange mesh can be obtained in 1D by setting <code>\"meshtype\":\"edge3\"</code>. AsFem currently offers the following mesh types:</p> <pre><code>edge2,edge3,edge4 // in 1D case\nquad4,quad8,quad9 // in 2D case\nhex8, hex20,hex27 // in 3D case\n</code></pre> <p>If users want to save the mesh created by AsFem, they need to set the \"savemesh\" option within the \"mesh\" block to true. The mesh will be saved as a .vtu file named as 'your_input_file_name' + _mesh.vtu (the .i extension in the input file name is removed). For example, if the input file name is test.json, the mesh file name will be test_mesh.vtu.</p>","tags":["tutorial","input file","mesh"]},{"location":"Tutorial/step-1/#2d-and-3d-mesh","title":"2D and 3D mesh","text":"<p>Similarly, for 2D and 3D cases, one can use:</p> <pre><code>\"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":2,\n        \"nx\":5,\n        \"ny\":15,\n        \"xmax\":0.5,\n        \"ymax\":1.5,\n        \"meshtype\":\"quad4\",\n        \"savemesh\":true\n    }\n</code></pre> <p>and</p> <pre><code>\"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":3,\n        \"nx\":5,\n        \"ny\":20,\n        \"nz\":20,\n        \"xmax\":0.5,\n        \"ymax\":0.5,\n        \"zmax\":2.0,\n        \"meshtype\":\"hex8\",\n        \"savemesh\":true\n    }\n</code></pre> <p>Or, one can also use:</p> <pre><code>\"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":3,\n        \"nx\":5,\n        \"ny\":20,\n        \"nz\":20,\n        \"meshtype\":\"hex8\",\n        \"savemesh\":true\n    }\n</code></pre> <p>them a unit domain <code>[0,1]x[0,1]x[0,1]</code> will be used by default in 3D cases.</p>","tags":["tutorial","input file","mesh"]},{"location":"Tutorial/step-1/#first-try-in-asfem","title":"First try in AsFem","text":"<p>To try the first example in AsFem, users can either create a new text file or use their preferred text editor. Here are some examples using <code>nano</code> or <code>vim</code>:</p> <pre><code>nano firstrun.json\n</code></pre> <p>or</p> <pre><code>vim firstrun.json\n</code></pre> <p>then copy and paste the following <code>mesh</code> block into your <code>firstrun.json</code>:</p> <pre><code>\"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":1,\n        \"nx\":20,\n        \"xmax\":1.5,\n        \"meshtype\":\"edge2\",\n        \"savemesh\":true\n    }\n</code></pre> <p>save it and then execute your <code>AsFem</code> as follows:</p> <pre><code>asfem -i firstrun.json --read-only\n</code></pre> <p>or in parallel:</p> <pre><code>mpirun -np 4 asfem -i firstrun.json --read-only\n</code></pre> <p>Here one need the <code>--read-only</code> option, since we do not have a complete input file but only the <code>mesh</code> block. If everthing works fine, you should see the following output:</p> <pre><code>******************************************************************************\n*** Welcome to use AsFem                                      AAA          ***\n*** A Simple Finite Element Method Program                   // \\\\         ***\n*** Version: 0.80        Release @ 2022-10-19               //   \\\\        ***\n*** PETSc version:  3.18.5                                 //     \\\\       ***\n*** License: GPL-3.0                                      //       \\\\      ***\n*** Author: Yang Bai @ M3-Group                          //_________\\\\     ***\n*** Contact: yangbai90@outlook.com                      //-----------\\\\    ***\n*** QQ Group: 879908352                                //             \\\\   ***\n*** Website: https://github.com/M3Group/AsFem         //               \\\\  ***\n*** Feel free to use and discuss  .:.                **                 ** ***\n******************************************************************************\n******************************************************************************\n*** Start to read the input file                                           ***\n*** mesh generator is done, your mesh is generated                         ***\n*** save mesh to step1-3d-mesh.vtu                                         ***\n******************************************************************************\n******************************************************************************\n*** Warning:no [bcs] block found in your input file, then the 'zero' n !!! ***\n***         eumann bc is assumed                                       !!! ***\n******************************************************************************\n******************************************************************************\n*** Warning:no [ics] block found in your input file, then no any initi !!! ***\n***         al conditions will be applied                              !!! ***\n******************************************************************************\n******************************************************************************\n*** Warning:no [projection] block found in your input file, then no qu !!! ***\n***         antities will be projected                                 !!! ***\n******************************************************************************\n******************************************************************************\n*** Warning:no [postprocess] block found in your input file, then no p !!! ***\n***         ostprocess will be executed                                !!! ***\n******************************************************************************\n******************************************************************************\n*** Warning:no [nlsolver] block found in your input file, then the def !!! ***\n***         ault options will be used                                  !!! ***\n******************************************************************************\n******************************************************************************\n*** Warning:no [output] block found in your input file, then the defau !!! ***\n***         lt options will be used                                    !!! ***\n******************************************************************************\n*** Input file reading is done, elapsed time=   7.00000e-03 [s]            ***\n******************************************************************************\n******************************************************************************\n*** Mesh information summary                                               ***\n***   nodes=    2646, nodes per bulk elmt=  8, max dim= 3, min dim= 2      ***\n***   elmts=    3200, bulk=    2000, surf=    1200, line=       0          ***\n***   bulk mesh type is hex8, mesh order= 1                                ***\n***   total physical group=    7, nodeset physical group=    6             ***\n***------------------------------------------------------------------------***\n***   phy id              phy name       dim       nodes/elmt       elmts  ***\n***      1                   left         2             4            400   ***\n***      2                  right         2             4            400   ***\n***      3                 bottom         2             4            100   ***\n***      4                    top         2             4            100   ***\n***      5                   back         2             4            100   ***\n***      6                  front         2             4            100   ***\n***      7              alldomain         3             8           2000   ***\n***------------------------------------------------------------------------***\n***   nodal phy id             phy name             nodes number           ***\n***      1000                     left                      441            ***\n***      2000                    right                      441            ***\n***      3000                   bottom                      126            ***\n***      4000                      top                      126            ***\n***      5000                     back                      126            ***\n***      6000                    front                      126            ***\n******************************************************************************\n***------------------------------------------------------------------------***\n*** 1 CPU is used for the simulation                                       ***\n***------------------------------------------------------------------------***\n*** AsFem has been executed in 'read-only' mode                            ***\n******************************************************************************\n*** 'Simulation' is done, elapsed time=   9.00000e-03 [s]                  ***\n******************************************************************************\n</code></pre> <p>Afterwards, you can visualize the generated 3D mesh using Paraview. The resulting visualization should resemble the following image: </p> <p>As a practice for the <code>mesh</code> block, we recommend trying different options to generate the desired mesh before proceeding to the next step.</p> <p>The complete input files can be found in the <code>examples/tutorial</code> directory.</p>","tags":["tutorial","input file","mesh"]},{"location":"Tutorial/step-2/","title":"Introduction","text":"<p>In the first step of our analysis, which is detailed in step-1, we defined the mesh. However, additional information is required to conduct a basic finite element analysis. As such, we will proceed by defining the degrees of freedom (DoFs) and the model in this step. Finally, we will apply the relevant boundary conditions to obtain the desired solution.</p>"},{"location":"Tutorial/step-2/#the-poisson-equation","title":"The poisson equation","text":"<p>The issue we want to solve is the linear Poisson equation that reads as follows: $$ \\begin{equation} \\sigma\\nabla^{2}\\phi=f \\label{eq:poisson} \\tag{1} \\end{equation} $$ where \\(\\sigma\\) and \\(f\\) denote the model's coefficients. Below are the related boundary conditions: $$ \\begin{equation} \\sigma\\nabla\\phi\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:neumann} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\phi=\\phi_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where the Dirichlet boundary condition and Neumann boundary condition are represented by the subscripts \\(D\\) and \\(N\\).</p>"},{"location":"Tutorial/step-2/#define-the-degree-of-freedom-dof","title":"Define the degree of freedom (DoF)","text":"<p>The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions (<code>[bcs]</code>), elements (<code>[elmts]</code>), and so on. The <code>[dofs]</code> block looks like below:</p> <p>The degrees of freedom (DoF), or DoFs, are used to assign names to each DoF and to apply the required boundary conditions (<code>bcs</code>) and elements (<code>elements</code>). The block of code defining the DoFs is presented below as <code>dofs</code>:</p> <pre><code>\"dofs\":{\n        \"names\":[\"dof-a\",\"dof-b\",\"dof-c\",...,\"dof-x\"]\n    }\n</code></pre>"},{"location":"Tutorial/step-2/#options","title":"Options","text":"<p>The <code>dofs</code> block includes an option called names, which is used to specify the name of each degree of freedom. It is important to note that the order in which the names are listed corresponds to the index of each degree of freedom. For example, in a 2D elastic analysis, two displacement degrees of freedom are required, namely <code>disp_x</code> and <code>disp_y</code>. The <code>dofs</code> block should thus be defined as follows:</p> <pre><code>\"dofs\":{\n        \"names\":[\"disp_x\",\"disp_y\"]\n    }\n</code></pre> <p>In this specific case, <code>disp_x</code> is assigned as the first degree of freedom with an index of 1, while <code>disp_y</code> is assigned as the second degree of freedom with an index of 2. Note that the only option available in the <code>dofs</code> block is <code>names</code>, with no additional options</p> <p>Since the Poisson equation involves only a single degree of freedom, the final expression for the <code>dofs</code> block is as follows</p> <pre><code>\"dofs\":{\n        \"names\":[\"phi\"]\n    }\n</code></pre>"},{"location":"Tutorial/step-2/#element-for-poisson-equation","title":"Element for Poisson equation","text":"<p>With the degree of freedom established, we now need to define the model in Eq.\\(\\eqref{eq:poisson}\\). To accomplish this, we use the <code>elements</code> block, which is defined as follows:</p> <pre><code>\"elements\":{\n        \"elmt1\":{\n            \"type\":\"poisson\",\n            \"dofs\":[\"phi\"],\n            \"material\":{\n                \"type\":\"constpoisson\",\n                \"parameters\":{\n                    \"sigma\":1.0,\n                    \"f\":1.0e1\n                }\n            }\n        }\n    }\n</code></pre> <p>The <code>type</code> option specifies the element or model to be used, which may be one of the built-in elements in AsFem or a user-defined element (<code>UEL</code>). The degrees of freedom to be used in the element are defined by the <code>dofs</code> option, while the material option specifies the name of the material sub-block to be used. Once the <code>elements</code> block is defined, the model described in Eq.\\(\\eqref{eq:poisson}\\) is complete.</p>"},{"location":"Tutorial/step-2/#material-properties","title":"Material properties","text":"<p>The coefficients \\(k\\) and \\(F\\), which correspond to the material properties in Eq.\\(\\eqref{eq:poisson}\\), can be calculated or defined using the <code>material</code> sub-block, as shown below:</p> <pre><code>\"material\":{\n                \"type\":\"constpoisson\",\n                \"parameters\":{\n                    \"sigma\":1.0,\n                    \"f\":1.0e1\n                }\n            }\n</code></pre> <p>The <code>material</code> sub-block includes the <code>type</code> option, which specifies the name of the material type defined in AsFem. The parameters option is used to define the parameters that will be used in our model. In this case, we will use \\(\\sigma=1.0\\) and \\(f=10.0\\)</p>"},{"location":"Tutorial/step-2/#boundary-conditions","title":"Boundary conditions","text":"<p>The boundary conditions described in Eq.\\(\\eqref{eq:dirichlet}\\) and \\(\\eqref{eq:neumann}\\) can be applied using the <code>bcs</code> block. In our case, the Neumann boundary condition in Eq.\\(\\eqref{eq:neumann}\\) is zero, and thus, only the Dirichlet boundary condition needs to be taken into account:</p> <pre><code>\"bcs\":{\n        \"left\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"phi\"],\n            \"bcvalue\":0.1,\n            \"side\":[\"left\"]\n        },\n        \"right\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"phi\"],\n            \"bcvalue\":0.5,\n            \"side\":[\"right\"]\n        }\n    }\n</code></pre> <p>The <code>left</code> and <code>right</code> sub-block is used to specify different boundary conditions for the left and right boundaries. The <code>type</code> option within each sub-block is used to specify the type of boundary condition, which is supported by AsFem. The <code>dof</code> option denotes the name of the DoF to which the given boundary conditions will be applied. In our case, we constrain the value of \\(\\phi\\) on the left and right sides of a rectangular domain to be 0.1 and 0.5, respectively.</p>"},{"location":"Tutorial/step-2/#static-analysis","title":"Static analysis","text":"<p>Now that the model and boundary conditions have been defined, we are ready to begin the FEM calculation. To specify the type of analysis we want to perform, we use the <code>job</code> block. In this case, since we are conducting a static analysis, the block can be defined as follows:</p> <pre><code>\"job\":{\n        \"type\":\"static\",\n        \"print\":\"on\",\n    }\n</code></pre> <p>If you want to observe how the iteration information changes during the analysis, you can use the following:</p> <pre><code>\"job\":{\n        \"type\":\"static\",\n        \"print\":\"dep\",\n        \"restart\":true\n    }\n</code></pre> <p>The <code>print</code> option is used to enable basic information output in the terminal. If you prefer to see fewer outputs, you can use <code>\"print\":\"off\"</code>.</p>"},{"location":"Tutorial/step-2/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>To proceed with the second example in AsFem, create a new text file and name it <code>step2.json</code>, or a name of your choosing. Next, copy the following lines into your input file:</p> <pre><code>{\n    \"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":2,\n        \"nx\":50,\n        \"ny\":50,\n        \"meshtype\":\"quad4\",\n        \"savemesh\":true\n    },\n    \"dofs\":{\n        \"names\":[\"phi\"]\n    },\n    \"elements\":{\n        \"elmt1\":{\n            \"type\":\"poisson\",\n            \"dofs\":[\"phi\"],\n            \"material\":{\n                \"type\":\"constpoisson\",\n                \"parameters\":{\n                    \"sigma\":1.0,\n                    \"f\":1.0e1\n                }\n            }\n        }\n    },\n    \"projection\":{\n        \"type\":\"default\",\n        \"vectormate\":[\"gradu\"]\n    },\n    \"bcs\":{\n        \"left\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"phi\"],\n            \"bcvalue\":0.1,\n            \"side\":[\"left\"]\n        },\n        \"right\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"phi\"],\n            \"bcvalue\":0.5,\n            \"side\":[\"right\"]\n        }\n    },\n    \"nlsolver\":{\n        \"type\":\"newton\",\n        \"solver\":\"gmres\",\n        \"maxiters\":50,\n        \"abs-tolerance\":5.0e-7,\n        \"rel-tolerance\":5.0e-10,\n        \"s-tolerance\":0.0,\n        \"preconditioner\":\"jacobi\"\n    },\n    \"output\":{\n        \"type\":\"vtu\",\n        \"interval\":1\n    },\n    \"qpoints\":{\n        \"bulk\":{\n            \"type\":\"gauss-legendre\",\n            \"order\":2\n        }\n    },\n    \"job\":{\n        \"type\":\"static\",\n        \"print\":\"dep\",\n        \"restart\":true\n    }\n}\n</code></pre> <p>You can also find the complete input file in <code>examples/tutorial</code>.</p> <p>If everything goes well, you can see the following image in your Paraview: </p> <p>Wait a second, what should I do if I want to solve a Poisson equation in 3D?</p> <p>The solution is straightforward - you just need to modify your mesh to be 3D. Here is an example of how you can do this using the input file <code>step2-3d.json</code>:</p> <pre><code>\"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":3,\n        \"nx\":50,\n        \"ny\":50,\n        \"nz\":50,\n        \"meshtype\":\"hex8\",\n        \"savemesh\":true\n    }\n</code></pre> <p>then you will see: </p>"},{"location":"Tutorial/step-3/","title":"Introduction","text":"<p>In this step, we will try to solve the linear elasticity problem.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#the-stress-equilibrium-equation","title":"The stress equilibrium equation","text":"<p>The problem we want to solve is the equation of stress equilibrium (without body force and acceleration) that reads as follows: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-eq} \\tag{1} \\end{equation} $$ where \\(\\mathbf{\\sigma}\\) denotes Cauchy stress tensor. Below are the constitutive laws for stress and strain in the case of small deformations: $$ \\begin{equation} \\mathbf{\\sigma}=\\mathbb{C}:\\mathbf{\\epsilon} \\label{eq:stress} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{\\epsilon}=\\frac{1}{2}(\\nabla\\mathbf{u}+\\nabla \\mathbf{u}^{T}) \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where \\(\\mathbf{u}\\) is the displacement vector. \\(\\mathbb{C}\\) represents the elasticity tensor, which is a function of the Youngs modulus \\(E\\) and Poisson ratio \\(\\nu\\).</p> <p>The related boundary conditions can be read as: $$ \\begin{equation} \\mathbf{t}\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:traction} \\tag{4} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{u}=\\mathbf{u}_{0}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:disp} \\tag{5} \\end{equation} $$ where the traction free condition is assumed in Eq.\\(\\eqref{eq:traction}\\)</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#define-a-mesh","title":"Define a mesh","text":"<p>We will be using a rectangular domain for our calculations. To define this domain, we use the <code>mesh</code> block, which can be expressed as follows:</p> <pre><code>\"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":2,\n        \"nx\":50,\n        \"ny\":50,\n        \"xmax\":5.0,\n        \"ymax\":5.0,\n        \"meshtype\":\"quad4\",\n        \"savemesh\":true\n    },\n</code></pre> <p>where a \\(50\\times50\\) mesh is defined.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#define-the-dofs","title":"Define the DoFs","text":"<p>In this step, the displacement vector is used as the degree of freedom, specifically \\(u_{x}\\) and \\(u_{y}\\). The <code>dofs</code> block can be expressed as follows:</p> <pre><code>\"dofs\":{\n        \"names\":[\"ux\",\"uy\"]\n    }\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#element-for-stress-equilibrium-equation","title":"Element for stress equilibrium equation","text":"<p>The model given in Eq.\\(\\eqref{eq:stress-eq}\\) can be implemented using the following lines:</p> <pre><code>\"elements\":{\n        \"elmt1\":{\n            \"type\":\"mechanics\",\n            \"dofs\":[\"ux\",\"uy\"],\n            \"material\":{\n                \"type\":\"linearelastic\",\n                \"parameters\":{\n                    \"E\":1.0e3,\n                    \"nu\":0.3\n                }\n            }\n        }\n    }\n</code></pre> <p>The <code>\"type\":\"mechanics\"</code> option in the above lines specifies the element to be used for the solid mechanics problem. Additionally, since we will be using linear elasticity material properties, the related material definition will be provided in the <code>material</code> block.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#linear-elasticity-material","title":"Linear elasticity material","text":"<p>The following lines within the <code>material</code> block can be used to define the linear elasticity material:</p> <pre><code>\"material\":{\n                \"type\":\"linearelastic\",\n                \"parameters\":{\n                    \"E\":1.0e3,\n                    \"nu\":0.3\n                }\n            }\n</code></pre> <p>where <code>\"type\":\"linearelastic\"</code> specifies linear elasticity material model. <code>parameters</code> defines the Youngs modulus (\\(E=100GPa\\)) and Poisson ratio (\\(\\nu=0.3\\)). </p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#it-is-worth-noting-that-asfem-does-not-enforce-any-specific-unit-system-or-interpret-results-in-a-particular-unit-therefore-the-user-must-ensure-that-the-input-parameters-and-result-interpretation-are-consistent-with-their-intended-application","title":"It is worth noting that AsFem does not enforce any specific unit system or interpret results in a particular unit. Therefore, the user must ensure that the input parameters and result interpretation are consistent with their intended application..","text":"","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#boundary-conditions","title":"Boundary conditions","text":"<p>The boundary conditions mentioned in Eq.\\(\\eqref{eq:disp}\\) can be implemented using the <code>bcs</code> block. In this case, since the traction boundary condition in Eq.\\(\\eqref{eq:traction}\\) is zero, we only need to consider the displacement boundary condition.</p> <pre><code>\"bcs\":{\n        \"fix\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"ux\",\"uy\"],\n            \"bcvalue\":0.0,\n            \"side\":[\"bottom\"]\n        },\n        \"load\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"uy\"],\n            \"bcvalue\":0.1,\n            \"side\":[\"top\"]\n        }\n    }\n</code></pre> <p>where we fix \\(u_{x}\\) and \\(u_{y}\\) to be zero at the bottom edge of the domain, while \\(u_{y}=0.1\\) is applied at the top edge.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#static-analysis","title":"Static analysis","text":"<p>To start the FEM calculation, we need to use the <code>job</code> block. The following lines can be used for this purpose:</p> <pre><code>\"job\":{\n        \"type\":\"static\",\n        \"print\":\"dep\"\n    }\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#projection","title":"Projection","text":"<p>Wait for a second, where are the stresses and strain? How can I output them? </p> <p>Noooo worries, the <code>projection</code> block can be used to project the quantities from each <code>Gauss point</code> to the <code>Nodal point</code> of your mesh. To visualize the vonMises stress, \\(\\sigma_{xx}\\), \\(\\sigma_{yy}\\), and \\(\\sigma_{xy}\\), you can use the following code:</p> <pre><code>\"projection\":{\n        \"type\":\"default\",\n        \"scalarmate\":[\"vonMises-stress\"],\n        \"rank2mate\":[\"stress\",\"strain\"]\n    }\n</code></pre> <p>The default option for the <code>projection</code> block (<code>\"type\":\"default\"</code>) will execute the simplified least squares projection algorithm.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#explanation-of-projection","title":"Explanation of projection","text":"<p>The <code>projection</code> block is not a magic tool. If you examine the LinearElasticMaterial.cpp file in the MateSystem class, you will find the following code:</p> <pre><code>mate.ScalarMaterial(\"vonMises-stress\")=sqrt(1.5*m_devStress.doubledot(m_devStress));\nmate.Rank2Material(\"strain\")=m_strain;\nmate.Rank2Material(\"stress\")=m_stress;\n</code></pre> <p>The material properties, which include scalar, vector, and tensor materials, are stored in the material class and can be easily accessed using their respective material names. Users only need to provide the names of the output material properties in the <code>projection</code> block. Additionally, the general tensor form used in this block is designed to work for all dimensions, from 1D to 3D.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-3/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>To try the third example in AsFem, create a new text file and name it <code>step3.json</code> or any other name you prefer. Then, copy and paste the following lines into your input file:</p> <pre><code>{\n    \"mesh\":{\n        \"type\":\"asfem\",\n        \"dim\":2,\n        \"nx\":50,\n        \"ny\":50,\n        \"xmax\":5.0,\n        \"ymax\":5.0,\n        \"meshtype\":\"quad4\",\n        \"savemesh\":true\n    },\n    \"dofs\":{\n        \"names\":[\"ux\",\"uy\"]\n    },\n    \"elements\":{\n        \"elmt1\":{\n            \"type\":\"mechanics\",\n            \"dofs\":[\"ux\",\"uy\"],\n            \"material\":{\n                \"type\":\"linearelastic\",\n                \"parameters\":{\n                    \"E\":1.0e3,\n                    \"nu\":0.3\n                }\n            }\n        }\n    },\n    \"projection\":{\n        \"type\":\"default\",\n        \"scalarmate\":[\"vonMises-stress\"],\n        \"rank2mate\":[\"stress\",\"strain\"]\n    },\n    \"nlsolver\":{\n        \"type\":\"newton\",\n        \"solver\":\"gmres\",\n        \"maxiters\":50,\n        \"abs-tolerance\":5.0e-7,\n        \"rel-tolerance\":5.0e-10,\n        \"s-tolerance\":0.0,\n        \"preconditioner\":\"lu\"\n    },\n    \"output\":{\n        \"type\":\"vtu\",\n        \"interval\":1\n    },\n    \"bcs\":{\n        \"fix\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"ux\",\"uy\"],\n            \"bcvalue\":0.0,\n            \"side\":[\"bottom\"]\n        },\n        \"load\":{\n            \"type\":\"dirichlet\",\n            \"dofs\":[\"uy\"],\n            \"bcvalue\":0.1,\n            \"side\":[\"top\"]\n        }\n    },\n    \"qpoints\":{\n        \"bulk\":{\n            \"type\":\"gauss-legendre\",\n            \"order\":2\n        }\n    },\n    \"job\":{\n        \"type\":\"static\",\n        \"print\":\"dep\"\n    }\n}\n</code></pre> <p>It's worth noting that if the <code>\"preconditioner\":\"lu\"</code> option in the <code>nlsolver</code> block doesn't work, you may need to either change <code>lu</code> to <code>jacobi</code>, or install MUMPS or SuperLU for your PETSc.</p> <p>You can also find the complete input file in <code>examples/tutorial/step3-2d.json</code>.</p> <p>If everything goes well, you can see the following images in your Paraview:  </p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","mechanics","projection"]},{"location":"Tutorial/step-4/","title":"Introduction","text":"<p>In this step, we will try to solve the linear diffusion problem.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#the-diffusion-equation","title":"The diffusion equation","text":"<p>The problem we want to solve is the diffusion equation that reads as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(D\\nabla c) \\label{eq:diffusion-eq} \\tag{1} \\end{equation} $$ where \\(c\\) denotes the concentration of the species. \\(D\\) is the diffusion coefficient</p> <p>The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=-0.5\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{2} \\end{equation} $$ where the flux (Neumann) boundary condition is assumed in Eq.\\(\\eqref{eq:flux}\\).</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#define-the-mesh","title":"Define the mesh","text":"<p>For our calculation, we use a cubic domain here, and then the <code>[mesh]</code> block can be given as:</p> <pre><code>[mesh]\n  type=asfem\n  dim=3\n  xmax=1.0\n  ymax=1.0\n  zmax=10.0\n  nx=5\n  ny=5\n  nz=50\n  meshtype=hex8\n[end]\n</code></pre> <p>where a \\(1\\times1\\times10\\) mesh is defined.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#define-the-dofs","title":"Define the DoFs","text":"<p>The DoFs used in this step is the concentration, namely \\(c\\). Then the <code>[dofs]</code> block can be read as:</p> <pre><code>[dofs]\nname=c\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#element-for-the-diffusion-equation","title":"Element for the diffusion equation","text":"<p>The model in Eq.\\(\\eqref{eq:diffusion-eq}\\) can be applied in the following lines</p> <pre><code>[elmts]\n  [mydiffusion]\n    type=diffusion\n    dofs=c\n    mate=mymate\n  [end]\n[end]\n</code></pre> <p>where <code>type=diffusion</code> option specifies the element we want to use for the diffusion problem. Moreover, we will use the constant diffusivity material property, therefore, the related material definition will be given in <code>mymate</code> block.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#constant-diffusivity-material-property","title":"Constant diffusivity material property","text":"<p>Via the following lines in your <code>[mates]</code> block, the constant diffusivity \\(D\\) can be easily defined:</p> <pre><code>[mates]\n  [mymate]\n    type=constdiffusion\n    params=1.0e1\n  [end]\n[end]\n</code></pre> <p>where <code>type=constdiffusion</code> specifies constant diffusivity material type. <code>params=</code> defines the diffusivity \\(D\\) (\\(D=10.0\\)).</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#boundary-conditions","title":"Boundary conditions","text":"<p>The boundary conditions, as mentioned in Eq.\\(\\eqref{eq:flux}\\), can be applied via the <code>[bcs]</code> block. In our case, only the flux boundary (Neumann) condition needs to be considered:</p> <pre><code>[bcs]\n  [flux]\n    type=neumann\n    dof=c\n    value=-0.5\n    boundary=front\n  [end]\n[end]\n</code></pre> <p>where we apply a constant flux to the front surface of our cubic domain.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#transient-analysis","title":"Transient analysis","text":"<p>Again, we need a <code>[job]</code> block to start the FEM calculation, which can be given as follows:</p> <pre><code>[job]\n  type=transient\n  debug=dep\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#timestepping","title":"Timestepping","text":"<p>Wait for a minute, where are the settings for the transient analysis, for instance the initial \\(\\Delta_t\\) and the final time? Noooo worries, the <code>[timestepping]</code> block can help you to set the different time stepping method as well as the \\(\\Delta_t\\), \\(T_{\\mathrm{final}}\\) stuffs. The layout of this block looks like below:</p> <pre><code>[timestepping]\n  type=be\n  dt=1.0e-3\n  time=1.0e0\n[end]\n</code></pre> <p>where <code>type=be</code> specifies the Backward-Euler (be) method for implicit time integration. It should be mentioned that, AsFem only support the implicit method, the explicit method like Forward-Euler (fe) is not supported! <code>dt=1.0e-3</code> defines that the initial \\(\\Delta_{t}\\) is \\(10^{-3}\\), while <code>time=1.0e0</code> means the final time is 1.0.</p> <p>Done!</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>Now, let's try your fourth example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file:</p> <pre><code>[mesh]\n  type=asfem\n  dim=3\n  xmax=1.0\n  ymax=1.0\n  zmax=10.0\n  nx=5\n  ny=5\n  nz=50\n  meshtype=hex8\n[end]\n\n[dofs]\nname=c\n[end]\n\n[elmts]\n  [mydiffusion]\n    type=diffusion\n    dofs=c\n    mate=mymate\n  [end]\n[end]\n\n[mates]\n  [mymate]\n    type=constdiffusion\n    params=1.0e1\n  [end]\n[end]\n\n[bcs]\n  [flux]\n    type=neumann\n    dof=c\n    value=-0.5\n    boundary=front\n  [end]\n[end]\n\n[timestepping]\n  type=be\n  dt=1.0e-3\n  time=1.0e0\n[end]\n\n[job]\n  type=transient\n  debug=dep\n[end]\n</code></pre> <p>You can also find the complete input file in <code>examples/tutorial/step4.i</code>.</p> <p>If everything goes well, you can see the following image in your Paraview: </p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-4/#the-outputs","title":"The outputs","text":"<p>You may see the following outputs from your terminal:</p> <pre><code>***-----------------------------------------------------------------------***\n***   SNES solver:iters=  0,|R|= 1.4306e-02,|dU|= 3.0700e+00,dt=1.00e-03  ***\n***   SNES solver:iters=  1,|R|= 1.3957e-15,|dU|= 2.4301e-03,dt=1.00e-03  ***\n*** Time step=     999, time=  9.99000e-01, dt=  1.00000e-03              ***\n*** Write result to step4-00000999.vtu                                    ***\n***-----------------------------------------------------------------------***\n***   SNES solver:iters=  0,|R|= 1.4303e-02,|dU|= 3.0723e+00,dt=1.00e-03  ***\n***   SNES solver:iters=  1,|R|= 1.3530e-15,|dU|= 2.4296e-03,dt=1.00e-03  ***\n*** Time step=    1000, time=  1.00000e+00, dt=  1.00000e-03              ***\n*** Write result to step4-00001000.vtu                                    ***\n***-----------------------------------------------------------------------***\n*** Time step=      -1, time=  1.00000e+00, dt=  1.00000e-03              ***\n*** Write result to step4-000000-1.vtu                                    ***\n***-----------------------------------------------------------------------***\n</code></pre> <p>One can see that, when the current time \\(t\\) reaches \\(1.0\\), the related output file name is <code>step4-00001000.vtu</code> (for the 1000-th step). Moreover, AsFem will also give the final output <code>step4-000000-1.vtu</code>, which could be very helpful when \\(t_{\\mathrm{old}}+\\Delta_{t}&gt;T_{\\mathrm{final}}\\).</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","diffusion","timestepping"]},{"location":"Tutorial/step-5/","title":"Introduction","text":"<p>In this step, we will try to solve the CahnHilliard equation for the spinodal decomposition problem.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#the-cahnhilliard-equation","title":"The CahnHilliard equation","text":"<p>The CahnHilliard equation can be read as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(M(c)\\nabla\\mu) \\label{eq:ch-c} \\tag{1} \\end{equation} $$ and $$ \\begin{equation} \\mu=\\frac{\\delta f}{\\delta c} \\label{eq:ch-mu} \\tag{2} \\end{equation} $$ where \\(c\\) and \\(\\mu\\) denote the concentration and chemical potential, respectively. \\(M(c)\\) is the concentration dependent mobility, in this model we use \\(M(c)=Dc(1-c)\\), where \\(D\\) is the diffusion coefficient.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#free-energy","title":"Free energy","text":"<p>In this model, we use the following free energy: $$ \\begin{equation} f=c\\ln(c)+(1-c)\\ln(1-c)+\\chi c(1-c)+\\kappa|\\nabla c|^{2} \\label{eq:free-energy} \\tag{3} \\end{equation} $$ thereby, the chemical potential \\(\\mu\\) can be expressed as: $$ \\begin{equation} \\mu=\\ln(c)-\\ln(1-c)+\\chi(1-c)-\\kappa\\nabla^{2}c \\label{eq:mu} \\tag{4} \\end{equation} $$ where \\(\\chi\\) denotes the interaction between two phases. \\(\\kappa\\) represents the interface energy contribution, which is proportional to the thickness of the phase interface.</p> <p>The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{5} \\end{equation} $$ where the zero flux (Neumann) boundary condition is assumed in Eq.\\(\\eqref{eq:flux}\\).</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#define-the-mesh","title":"Define the mesh","text":"<p>We use a square domain here for our calculation, and then the <code>[mesh]</code> block can be given as:</p> <pre><code>[mesh]\n  type=asfem\n  dim=2\n  xmax=4.0\n  ymax=4.0\n  nx=100\n  ny=100\n  meshtype=quad4\n[end]\n</code></pre> <p>where a \\(4\\times4\\) mesh is defined.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#gauss-point-integration-optional","title":"Gauss point integration (optional)","text":"<p>If one wants to use second order mesh, for instance <code>meshtype=quad9</code>, then one need to use a higher order gauss points. This can be implemented via:</p> <pre><code>[qpoint]\n  type=gauss\n  order=3\n[end]\n</code></pre> <p>Normally, you don't need this block!</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#define-the-dofs","title":"Define the DoFs","text":"<p>In order to solve the 4th order equation, we split the CH equation into two second-order equations. Therefore, the DoFs used in this step are the concentration \\(c\\) and the chemical potential \\(\\mu\\). Then the <code>[dofs]</code> block can be read as:</p> <pre><code>[dofs]\nname=c mu\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#element-for-the-cahnhilliard-equation","title":"Element for the CahnHilliard equation","text":"<p>The model in Eq.\\(\\eqref{eq:ch-c}\\) and \\(\\eqref{eq:ch-mu}\\) can be applied in the following lines</p> <pre><code>[elmts]\n  [mych]\n    type=cahnhilliard\n    dofs=c mu\n    mate=myf\n  [end]\n[end]\n</code></pre> <p>where <code>type=cahnhilliard</code> option specifies the element we want to use for the CahnHilliard equation. Moreover, we will use the <code>free energy</code>(\\(F\\)), the <code>first order</code> derivative of free energy(\\(\\frac{\\partial F}{\\partial c}\\)), and the <code>second order</code> derivative of free energy(\\(\\frac{\\partial^{2}f}{\\partial c^{2}}\\)) material properties. Therefore, the related material definition will be given in <code>myf</code> block.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#free-energy-material","title":"free energy material","text":"<p>Via the following lines in your <code>[mates]</code> block, the material properties, i.e. \\(F\\), \\(\\frac{\\partial F}{\\partial c}\\), and \\(\\frac{\\partial^{2}F}{\\partial c^{2}}\\) can be easily defined:</p> <pre><code>[mates]\n  [myf]\n    type=cahnhilliard\n    params=1.0 2.5 0.005\n  [end]\n[end]\n</code></pre> <p>where <code>type=cahnhilliard</code> specifies constant diffusivity material type. Don't worry, here we used the same name as the <code>type=</code> in <code>[elmts]</code> block. But AsFem knows that they belong to two different blocks, so it's fine. <code>params=</code> defines the diffusivity \\(D=1.0\\), the phase interaction constant \\(\\chi=2.5\\), and the interface parameter \\(\\kappa=0.02\\). If you are using a coarse mesh, please increase \\(\\kappa\\) to a larger value, i.e. 0.02 or even higher.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#boundary-conditions","title":"Boundary conditions","text":"<p>Since the zero flux boundary condition is applied, we don't need any <code>[bcs]</code> block. If Eq.\\(\\eqref{eq:flux}\\) is nonzero, then you will definitely need the <code>[bcs]</code> block.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#transient-analysis","title":"Transient analysis","text":"<p>Again, we need a <code>[job]</code> block to start the FEM calculation, which can be given as follows:</p> <pre><code>[job]\n  type=transient\n  debug=dep\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#timestepping","title":"Timestepping","text":"<p>In this case, we will use the adaptive time stepping to speed up our simulation. The layout of our <code>[timestepping]</code> block looks like below:</p> <pre><code>[timestepping]\n  type=be\n  dt=1.0e-5\n  time=1.0e3\n  adaptive=true\n  optiters=3\n  growthfactor=1.1\n  cutfactor=0.85\n[end]\n</code></pre> <p>where <code>type=be</code> specifies the Backward-Euler (be) method for implicit time integration. <code>dt=1.0e-5</code> defines that the initial \\(\\Delta_{t}\\) and <code>time=1.0e3</code> means the final time is 1000.0. <code>adaptive=true</code> enables the adaptive time stepping. <code>optiters=3</code> indicates that if the nonlinear iterations is not greater than 3, then AsFem will increase the new delta t to be \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{growth}}\\). Otherwise, the new delta t will be reduced as \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{cut}}\\). <code>growthfactor</code> and <code>cutfactor</code> represent \\(\\alpha_{\\mathrm{growth}}\\) and \\(\\alpha_{\\mathrm{cut}}\\), respectively.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#initial-condition","title":"Initial condition","text":"<p>Now, in order to allow the phase separation to take place, we must add the random value to the concentration. As follows, the random concentration value can be applied through the'[ics]' block:</p> <pre><code>[ics]\n  [ic1]\n    type=random\n    dof=c\n    params=0.6 0.66\n  [end]\n[end]\n</code></pre> <p>where the random value is applied via the <code>type=random</code> option. <code>dof=</code> indicates which DoF will be used. <code>params=</code> represent the parameters used in the initial condition calculation. For the <code>type=random</code> case, 0.6 and 0.66 are the min and max value of the random numbers.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#parallel-solver","title":"Parallel solver","text":"<p>In order to further speed up our simulation, we involve the parallel solver from either mumps or superlu_dist. This can be defined via the <code>[nonlinearsolver]</code> block:</p> <pre><code>[nonlinearsolver]\n  type=nr\n  solver=superlu\n[end]\n</code></pre> <p>where <code>type=nr</code> indicates the newton-raphson method. <code>solver=</code> determines the name of the parallel solver, in this case, the superlu_dist solver is used. It should be noted that, if external solvers, i.e. <code>mumps</code> and <code>superlu</code>, are not compiled within your PETSc, then you can only use the built-in solver. In short, this option doesn\u2019t make sense to you.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-5/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>Now, let's try your fourth example in AsFem. You can create a new text file and name it as step5.i or whatever you like. Then copy the following lines into your input file:</p> <pre><code>[mesh]\n  type=asfem\n  dim=2\n  xmax=4.0\n  ymax=4.0\n  nx=100\n  ny=100\n  meshtype=quad4\n[end]\n\n[dofs]\nname=c mu\n[end]\n\n[elmts]\n  [mych]\n    type=cahnhilliard\n    dofs=c mu\n    mate=myf\n  [end]\n[end]\n\n[mates]\n  [myf]\n    type=cahnhilliard\n    params=1.0 2.5 0.005\n    //     D   Chi Kappa\n  [end]\n[end]\n\n[timestepping]\n  type=be\n  dt=1.0e-5\n  time=3.0e3\n  adaptive=true\n  optiters=3\n  growthfactor=1.1\n  cutfactor=0.85\n[end]\n\n[nonlinearsolver]\n  type=nr\n  solver=superlu\n[end]\n\n[ics]\n  [ic1]\n    type=random\n    dof=c\n    params=0.6 0.66\n  [end]\n[end]\n\n[job]\n  type=transient\n  debug=dep\n[end]\n</code></pre> <p>You can also find the complete input file in <code>examples/tutorial/step5.i</code>.</p> <p>If everything goes well, you can see the following image in your Paraview: </p> <p></p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","cahnhilliard","timestepping"]},{"location":"Tutorial/step-6/","title":"Introduction","text":"<p>In this step, we will try to solve the linear momentum balance equation for the linear elastic problem.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#the-linear-momentum-balance-equation","title":"The linear momentum balance equation","text":"<p>The equation can be read as follows: $$ \\begin{equation} \\rho\\frac{\\partial v}{\\partial t}=\\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}+\\rho\\mathbf{b} \\label{eq:stress-equation} \\tag{1} \\end{equation} $$ with \\(\\rho\\) being the density, \\(\\mathbf{b}\\) denoting the body force (i.e., gravity), \\(\\mathbf{\\sigma}\\) being the Cauchy stress tensor. The boundary condition for this problem is defined as follows: $$ \\begin{equation} \\mathbf{u}=u_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D}\\qquad\\qquad \\mathbf{\\sigma}\\cdot\\vec{n}=\\mathbf{t}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\end{equation} $$</p> <p>Next, by using the weighted integration and integration by parts, one can obtain: $$ \\begin{equation} \\delta I[\\mathbf{u}]= \\int_{\\Omega}\\sigma_{ij}\\delta u_{i,j}dV -\\int_{\\Omega}\\rho b_{i}\\delta u_{i}dV -\\int_{\\partial\\Omega}t_{i}\\delta u_{i}dS=0 \\label{eq:weighted-integration} \\tag{2} \\end{equation} $$ then, the residual for \\(\\eqref{eq:weighted-integration}\\) can be expressed as follows: $$ \\begin{equation} R_{u_{i}}^{I}= \\int_{\\Omega}\\sigma_{ij}N_{,j}^{I}dV -\\int_{\\Omega}\\rho b_{i}N^{I}dV -\\int_{\\partial\\Omega_{N}}t_{i}N^{I}dS \\label{eq:residual} \\tag{3} \\end{equation} $$ where the \"acceleration\" term has been ignored. Then the related jacobian matrix can be given as follows: $$ \\begin{equation} K_{ik}^{IJ}=\\frac{\\partial R_{u_{i}}^{I}}{\\partial u_{k}^{J}} =\\int_{\\Omega}\\mathbb{C}_{ijkl} N_{,j}^{I}N_{,l}^{J}dV \\label{eq:jacobian} \\tag{4} \\end{equation} $$ where \\(\\mathbb{C}_{ijkl}\\) denotes the elasticity tensor. \\(I\\) and \\(J\\) respectively represent the I-th and J-th node of the current element.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#constitutive-laws","title":"Constitutive laws","text":"<p>For the small strain case, one can have $$ \\begin{equation} \\mathbf{\\varepsilon}=\\frac{1}{2}(\\nabla u+\\nabla^{T}u) \\label{eq:strain} \\tag{5} \\end{equation} $$ which can be easily calculated in AsFem as follows:</p> <pre><code>if(elmtinfo.nDim==1){\n  _GradU.SetFromGradU(elmtsoln.gpGradU[1]);\n}\nelse if(elmtinfo.nDim==2){\n  _GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2]);\n}\nelse if(elmtinfo.nDim==3){\n  _GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2],elmtsoln.gpGradU[3]);\n}\nStrain=(_GradU+_GradU.Transpose())*0.5;\n</code></pre> <p>For the linear elasticity tensor \\(\\mathbb{C}\\), you need to give the Young's modulus and poisson ratio, then its value can be defined as follows:</p> <pre><code>Jacobian.SetFromEandNu(E,nu);\n</code></pre> <p>where AsFem offers the <code>RankTwoTensor</code> and <code>RankFourTensor</code> class for the complex tensor calculation.</p> <p>Next, once your strain \\(\\mathbf{\\varepsilon}\\) and elasticity tensor \\(\\mathbb{C}\\) are ready, you can easily get your stress tensor \\(\\mathbf{\\sigma}\\) as follows:</p> <pre><code>Stress=Jacobian.DoubleDot(Strain);\n</code></pre> <p>That's all? Yup, all the calculation is done.</p> <p>If I want to calculate the <code>vonMises</code> stress, what should I do? The answer is quite simple, here is the code</p> <pre><code>RankTwoTensor I;\nI.SetToIdentity();\ndevStress=_Stress-_I*(_Stress.Trace()/3.0);\nMate.ScalarMaterials(\"vonMises\")=sqrt(1.5*_devStress.DoubleDot(_devStress));\n</code></pre> <p>once again, the complex tensor calculation is done by our <code>RankTwoTensor</code> class.</p> <p>So, for a general mechanics problem, what you need to tell AsFem are the <code>stress</code> and <code>jacobian</code> material properties (these two are required by the <code>mechanics</code> element) in the following way:</p> <pre><code>Mate.Rank2Materials(\"stress\")=Stress;\nMate.Rank4Materials(\"jacobian\")=Jac;\n</code></pre> <p>where the values of these two tensors are stored in the Material class.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#solve-the-problem","title":"Solve the problem","text":"","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#define-the-mesh","title":"Define the mesh","text":"<p>We use a square domain here for our calculation, and then the <code>[mesh]</code> block can be given as:</p> <pre><code>[mesh]\n  type=asfem\n  dim=2\n  xmax=2.0\n  ymax=2.0\n  nx=50\n  ny=50\n  meshtype=quad4\n[end]\n</code></pre> <p>where a \\(2\\times 2\\) mesh is defined.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#gauss-point-integration-optional","title":"Gauss point integration (optional)","text":"<p>If one wants to use second order mesh, for instance <code>meshtype=quad9</code> or <code>meshtype=hex27</code>, then one need to use a higher order gauss points. This can be implemented via:</p> <pre><code>[qpoint]\n  type=gauss\n  order=3[4]\n[end]\n</code></pre> <p>Normally, you don't need this block!</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#define-the-dofs","title":"Define the DoFs","text":"<p>The DoFs used in this step are the displacements \\(u_{x}\\) and \\(u_{y}\\). Then the <code>[dofs]</code> block can be read as:</p> <pre><code>[dofs]\nname=ux uy\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#element-for-the-cahnhilliard-equation","title":"Element for the CahnHilliard equation","text":"<p>The model presented in Eq.\\(\\eqref{eq:residual}\\) and \\(\\eqref{eq:jacobian}\\) can be applied in the following lines</p> <pre><code>[elmts]\n  [mysolid]\n    type=mechanics\n    dofs=ux uy\n    mate=mymate\n  [end]\n[end]\n</code></pre> <p>where <code>type=mechanics</code> option specifies the element we want to use for the linear momentum balance equation. Moreover, we will use the <code>mymate</code> material to calculate the necessary material properties required by this element.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#linear-elastic-material","title":"Linear elastic material","text":"<p>By using the following lines in your <code>[mates]</code> block, the material properties, i.e., (\\(\\varepsilon\\)), stress (\\(\\mathbf{\\sigma}\\)), and elasticity tensor (\\(\\mathbb{C}\\)) can be easily defined:</p> <pre><code>[mates]\n  [mymate]\n    type=linearelastic\n    params=210.0 0.3  \n    //     E     nu\n  [end]\n[end]\n</code></pre> <p>where <code>type=linearelastic</code> specifies linear elastic material we want to use. <code>params=</code> defines the Youngs modulus \\(E=210.0\\), the poisson ratio \\(\\nu=0.3\\).</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#boundary-conditions","title":"Boundary conditions","text":"<p>Now, we want to apply a displacement loading condition to the <code>top</code> edge of our rectangle domain and fix the <code>bottom</code> edge at the same time, then, we can use:</p> <pre><code>[bcs]\n  [FixUx]\n    type=dirichlet\n    dofs=ux uy\n    boundary=bottom\n    value=0.0\n  [end]\n  [loadUx]\n    type=dirichlet\n    dofs=uy\n    value=0.02\n    boundary=top\n  [end]\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#static-analysis","title":"Static analysis","text":"<p>Again, we need a <code>[job]</code> block to start the FEM calculation, which can be given as follows:</p> <pre><code>[job]\n  type=static\n  debug=dep\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#projection-for-materials","title":"Projection for materials","text":"<p>Hold on for a second, if I want to check the stress, strain, and vonMises stress, what should I do?</p> <p>The answer is the <code>[projection]</code> block, which can do the projection from gauss points to the nodal point. For example, if we want to save the strain, stress, and vonMises stress into our result file (vtu), one can do:</p> <pre><code>[projection]\nscalarmate=vonMises\nrank2mate=stress strain\n[end]\n</code></pre> <p>where <code>scalarmate</code> and <code>rank2mate</code> specify the material name we want to export. Afterwards, they will be displayed in your <code>Paraview</code>.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-6/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>Now, let's try your first mechanics example in AsFem. You can create a new text file and name it as step6.i or whatever you like. Then copy the following lines into your input file:</p> <pre><code>[mesh]\n  type=asfem\n  dim=2\n  xmax=2.0\n  ymax=2.0\n  nx=50\n  ny=50\n  meshtype=quad4\n[end]\n\n[dofs]\nname=ux uy\n[end]\n\n[elmts]\n  [mysolids]\n    type=mechanics\n    dofs=ux uy\n    mate=mymate\n  [end]\n[end]\n\n[mates]\n  [mymate]\n    type=linearelastic\n    params=210.0 0.3  \n    //     E     nu\n  [end]\n[end]\n\n[bcs]\n  [FixUx]\n    type=dirichlet\n    dofs=ux uy\n    boundary=bottom\n    value=0.0\n  [end]\n  [loadUx]\n    type=dirichlet\n    dofs=uy\n    value=0.02\n    boundary=top\n  [end]\n[end]\n\n[projection]\nscalarmate=vonMises\nrank2mate=stress strain\n[end]\n\n[nonlinearsolver]\n  type=nr\n  maxiters=20\n  r_rel_tol=5.0e-8\n  r_abs_tol=4.5e-7\n  solver=mumps\n[end]\n\n[job]\n  type=static\n  debug=dep\n[end]\n</code></pre> <p>You can also find the complete input file in <code>examples/tutorial/step6.i</code>.</p> <p>If everything goes well, you can see the following image in your Paraview: </p> <p></p> <p></p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","linear momentum balance","timestepping"]},{"location":"Tutorial/step-7/","title":"Introduction","text":"<p>In this step, we will try to write our first user-defined-material (UMAT). The equation we used here is still the linear momentum balance equation for the linear elastic problem. For more details, one is referred to step-6.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-7/#the-user-defined-material-umat","title":"The user-defined-material (umat)","text":"<p>In this step, we try to define a coordinate-dependent Young's modulus for our simulation, which can be read as follows: $$ \\begin{equation} E=E_{0}(1+\\delta\\cos(xy)) \\label{eq:E} \\tag{1} \\end{equation} $$ with \\(E_{0}\\) being the constant Youngs modulus, \\(\\delta\\) representing fluctuation. \\(x\\) and \\(y\\) are the coordinate.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-7/#write-code-for-your-umat-1","title":"Write code for your umat-1","text":"<p>AsFem offers several umat(1~10), which means you can easily write your code by editing the cpp file in the <code>src/MateSystem</code> folder. In this case, we will use <code>umat1</code>, then one can open the <code>User1Material.cpp</code> file with whichever text/code editor he/she likes.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-7/#constitutive-laws","title":"Constitutive laws","text":"<p>For the small strain case, one can have $$ \\begin{equation} \\mathbf{\\varepsilon}=\\frac{1}{2}(\\nabla u+\\nabla^{T}u). \\label{eq:strain} \\tag{2} \\end{equation} $$ For the 2D case, one can have:</p> <pre><code>GradU.SetFromGradU(elmtsoln.gpGradU[1],elmtsoln.gpGradU[2]);\nStrain=(GradU+GradU.Transpose())*0.5;\n</code></pre> <p>The <code>InputParams</code> variable can access the parameters we provide in our input file as follows:</p> <pre><code>E0=InputParams[1-1];\nnu=InputParams[2-1];\ndelta=InputParams[3-1];\n</code></pre> <p>then we can write out the following code for the Young's modulus list in Eq.\\(\\eqref{eq:E}\\) as follows:</p> <pre><code>x=elmtinfo.gpCoords(1);\ny=elmtinfo.gpCoords(2);\nE=E0*(1+delta*sin(x*y));\n</code></pre> <p>From <code>elmtinfo</code>, you can get all the information of the local element.</p> <p>Then we can set up the stress \\(\\mathbf{\\sigma}\\) and elasticity tensor \\(\\mathbb{C}\\) as follows:</p> <pre><code>Jacobian.SetFromEandNu(E,nu);\nStress=Jacobian.DoubleDot(Strain)\n</code></pre> <p>That's all? Yup, that's all for your first UMAT.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-7/#solve-the-problem","title":"Solve the problem","text":"","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-7/#choose-the-umat-1","title":"Choose the umat-1","text":"<p>Since you have wrote the code for your own material, then you should save the <code>User1Material.cpp</code> file and make AsFem again by running(you should have the Makefile, otherwise, please do <code>cmake CMakeLists.txt</code>):</p> <pre><code>make -j4\n</code></pre> <p>Then, you can tell AsFem to use the <code>User1Material</code> via:</p> <pre><code>[mates]\n  [mymate1]\n    type=user1\n    params=210.0 0.3 0.2\n    //     E0    nu  delta\n  [end]\n[end]\n</code></pre> <p>here <code>type=user1</code> means we will use the material model defined in <code>User1Material.cpp</code>. <code>InputParams</code> will store the <code>params</code> you give in the material block.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-7/#projection-for-materials","title":"Projection for materials","text":"<p>If I want to check the value of the coordinate-dependent Youngs modulus, what should I do?</p> <p>That's easy, you can define a scalar material as follows:</p> <pre><code>Mate.ScalarMaterials(\"MyE\")=E;\n</code></pre> <p>then in your <code>[projection]</code> block, you can use:</p> <pre><code>[projection]\nscalarmate=MyE vonMises\n[end]\n</code></pre> <p>Then you will see your \"MyE\" in the <code>Paraview</code>.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-7/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>Now, let's try your first umat example in AsFem. You can create a new text file and name it as step7.i or whatever you like. Then copy the following lines into your input file:</p> <pre><code>[mesh]\n  type=asfem\n  dim=2\n  xmax=10.0\n  ymax=10.0\n  nx=100\n  ny=100\n  meshtype=quad9\n[end]\n\n[qpoint]\n  type=gauss\n  order=4\n[end]\n\n[dofs]\nname=ux uy\n[end]\n\n[elmts]\n  [mysolids]\n    type=mechanics\n    dofs=ux uy\n    mate=mymate1\n  [end]\n[end]\n\n[mates]\n  [mymate1]\n    type=user1\n    params=210.0 0.3 0.2\n    //     E0    nu  delta\n  [end]\n[end]\n\n[projection]\nscalarmate=MyE vonMises\n[end]\n\n[bcs]\n  [fix]\n    type=dirichlet\n    dofs=ux uy\n    value=0.0\n    boundary=bottom\n  [end]\n  [load]\n    type=dirichlet\n    dofs=uy\n    value=0.02\n    boundary=top\n  [end]\n[end]\n\n[job]\n  type=static\n  debug=dep\n[end]\n</code></pre> <p>You can also find the complete input file in <code>examples/tutorial/step7.i</code>.</p> <p>If everything goes well, you can see the following image in your Paraview: </p> <p></p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat"]},{"location":"Tutorial/step-8/","title":"Introduction","text":"<p>In this step, we will try to implement our first user-defined-element (UEL). Now the equation we used here can be whatever you like. Let's take the heat conduct equation as an example.</p> <p>The general heat conduct equation takes the following form: $$ \\begin{equation} \\rho c_{p}\\frac{\\partial T}{\\partial t}=\\nabla(k\\nabla T)+\\dot{q}_{v} \\label{eq:T} \\tag{1} \\end{equation} $$ where \\(\\rho\\) is the density, \\(c_{p}\\) denotes the heat capacity, \\(\\dot{q}\\) is the volumetric heat source, \\(k\\) represents the thermal conductivity coefficient.</p> <p>The related boundary conditions can be list below: $$ \\begin{equation} T=T_{g}~\\mathrm{on}~\\Omega_{D},\\qquad\\mathrm{with}~-k\\nabla T\\cdot\\vec{n}=j_{0}~\\mathrm{on}~\\Omega_{N} \\label{eq:bc} \\tag{2} \\end{equation} $$</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#the-user-defined-element-uel","title":"The user-defined-element (uel)","text":"<p>In AsFem, users can define their own model (governing equations) by using the <code>uel</code>. In each uel, user must given the details for the related residual and jacobian calculation.</p> <p>In this step, we try to write out the code for our heat equation. The residual and system jacobian matrix for Eq.\\(\\eqref{eq:T}\\) can be read as follows:</p> \\[ \\begin{equation} \\begin{aligned} R_{T}^{I}&amp;=\\int_{\\Omega}\\rho c_{p}\\dot{T} N^{I}dV +\\int_{\\Omega}k\\nabla T\\nabla N^{I}dV -\\int_{\\Omega}\\dot{q}_{v}N^{I}dV -\\int_{\\partial\\Omega}k \\nabla T\\cdot\\vec{n}N^{I} dS \\\\ &amp;=\\int_{\\Omega}\\rho c_{p}\\dot{T} N^{I}dV +\\int_{\\Omega}k\\nabla T\\nabla N^{I}dV -\\int_{\\Omega}\\dot{q}_{v}N^{I}dV +\\int_{\\partial\\Omega}j_{0}N^{I} dS \\end{aligned} \\label{eq:residual} \\tag{3} \\end{equation} \\] <p>and $$ \\begin{equation} K_{TT}^{IJ}=\\frac{\\partial R_{T}^{I}}{\\partial T^{J}}=\\int_{\\Omega}\\rho c_{p}\\frac{\\partial\\dot{T}}{\\partial T}N^{J}N^{I}dV +\\int_{\\Omega}k\\nabla N^{J}\\nabla N^{I}dV \\label{eq:jacobian} \\tag{4} \\end{equation} $$</p> <p>Then, the formulation part is done!</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#writing-code-for-your-uel-1","title":"Writing code for your uel-1","text":"<p>AsFem offers several uel(1~20), which means you can easily write your code by editing the cpp file in the <code>src/ElmtSystem</code> folder. In this case, we will use <code>uel1</code>, then one can open the <code>User1Elmt.cpp</code> file with whichever text/code editor he/she likes.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#material-properties","title":"Material  properties","text":"<p>It is not necessary to call a material code for the calculation, but it could be very flexible if one combines <code>umat</code> and <code>uel</code>. Therefore, one can use one <code>umat</code> to calculate the material properties required by Eq.\\(\\eqref{eq:residual}\\) and Eq.\\(\\eqref{eq:jacobian}\\).</p> <p>For example, the built-in <code>thermalmate</code> defines:</p> <pre><code>Mate.ScalarMaterials(\"rho\")=InputParams[0];// density\nMate.ScalarMaterials(\"Cp\") =InputParams[1];// heat capacity\nMate.ScalarMaterials(\"K\")  =InputParams[2];// thermal conductivity\nMate.ScalarMaterials(\"Q\")  =InputParams[3];// body heat source\n</code></pre> <p>therefore, you can use <code>User1Mate</code> or <code>UserXMate</code> for the same purpose. Once your materials are ready, we can move on to the next step, your first uel!</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#uel","title":"UEL","text":"<p>For Eq.\\(\\eqref{eq:residual}\\), namely the residual computation, one can write:</p> <pre><code>localR(1)=_rho*_Cp*soln.gpV[1]*shp.test\n         +_K*(soln.gpGradU[1]*shp.grad_test)\n         -_Q*shp.test;\n</code></pre> <p>next, the system jacobian (Eq.\\(\\eqref{eq:jacobian}\\)) can be calculated as follows:</p> <pre><code>localK(1,1)=_rho*_Cp*shp.trial*shp.test*ctan[1]\n           +_K*(shp.grad_trial*shp.grad_test)*ctan[0];\n</code></pre> <p>That's all the code for your model, done!</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#solve-the-problem","title":"Solve the problem","text":"","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#choose-the-uel-1","title":"Choose the uel-1","text":"<p>Since you have wrote the code for your own element, then you should save the <code>User1Elmt.cpp</code> file and make AsFem again by running(you should have the Makefile, otherwise, please do <code>cmake CMakeLists.txt</code>):</p> <pre><code>make -j4\n</code></pre> <p>Then, you can tell AsFem to use the <code>User1Elmt</code> via:</p> <pre><code>[elmts]\n  [mythermal]\n    type=user1\n    dofs=T\n    mate=mymate\n  [end]\n[end]\n</code></pre> <p>here <code>type=user1</code> means we will use the heat equation defined in <code>User1Elmt.cpp</code>. The related material properties can be defined as follows:</p> <pre><code>[mates]\n  [mymate]\n    type=user2\n    params=1.0 1.5 2.0 0.0\n    //     rho Cp  K   Q\n  [end]\n[end]\n</code></pre>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#projection-for-materials","title":"Projection for materials","text":"<p>If one want to check the gradient of the temperature, one can define a vector material as follows:</p> <pre><code>Mate.VectorMaterials(\"gradT\")=elmtsoln.gpGradU[1];\n</code></pre> <p>then in your <code>[projection]</code> block, you can use:</p> <pre><code>[projection]\nvectormate=gradT\n[end]\n</code></pre> <p>Then you will see your <code>gradT</code> in the <code>Paraview</code>.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]},{"location":"Tutorial/step-8/#run-it-in-asfem","title":"Run it in AsFem","text":"<p>Now, let's try your first uel example in AsFem. You can create a new text file and name it as step8.i or whatever you like. Then copy the following lines into your input file:</p> <pre><code>[mesh]\n  type=asfem\n  dim=2\n  xmax=10.0\n  ymax=2.0\n  nx=100\n  ny=20\n  meshtype=quad9\n[end]\n\n[dofs]\nname=T\n[end]\n\n[elmts]\n  [mythermal]\n    type=user1\n    dofs=T\n    mate=mymate\n  [end]\n[end]\n\n[mates]\n  [mymate]\n    type=user2\n    params=1.0 1.5 2.0 0.0\n    //     rho Cp  K   Q\n  [end]\n[end]\n\n[bcs]\n  [flux]\n    type=neumann\n    dofs=T\n    value=-0.1\n    boundary=right\n  [end]\n[end]\n\n[timestepping]\n  type=be\n  dt=1.0e-5\n  dtmax=1.0e-2\n  time=1.0e-1\n  optiters=3\n  adaptive=true\n[end]\n\n[projection]\nvectormate=gradT\n[end]\n\n[job]\n  type=transient\n  debug=dep\n[end]\n</code></pre> <p>You can also find the complete input file in <code>examples/tutorial/step8.i</code>.</p>","tags":["tutorial","input file","mesh","dofs","elmts","mates","stress","umat","uel"]}]}